(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-3bd3"],{"77Bc":function(s,t,a){s.exports=a.p+"assets/bg-20190116-01.cd479d3.png"},AFnJ:function(s,t,a){a("CAwg"),s.exports=a("TaGV").Object.assign},CAwg:function(s,t,a){var v=a("/6KZ");v(v.S+v.F,"Object",{assign:a("tbIA")})},IWuo:function(s,t,a){"use strict";a.r(t);var v=a("PSh9"),n=a.n(v),_=a("Qi1R"),l={data:function(){return{info:{}}},created:function(){this.$route.query.info&&(this.info=n()({},JSON.parse(_.a.b64ToUtf8(this.$route.query.info))))}},i=a("psIG"),r=Object(i.a)(l,function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("div",{staticClass:"blog-container"},[v("Title",{attrs:{name:s.info.mainTitle}}),s._v(" "),v("BlogHeader",{attrs:{title:s.info.mainTitle,subTitle:s.info.subTitle,date:s.info.date,tags:s.info.tags}}),s._v(" "),v("BlogContent",[v("div",{attrs:{slot:"content"},slot:"content"},[v("h2",[s._v("前言")]),s._v(" "),v("p",[s._v("这是前端面试题系列的第 4 篇，你可能错过了前面的篇章，可以在这里找到：")]),s._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000017480929",target:"_blank"}},[s._v("今日头条 面试题和思路解析")])]),s._v(" "),v("li",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000017540629",target:"_blank"}},[s._v("如何实现一个圣杯布局？")])]),s._v(" "),v("li",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000017784553",target:"_blank"}},[s._v("伪类与伪元素的区别及实战")])])]),s._v(" "),v("p",[s._v("\n                在前端的面试中，经常会问到有关 this 的指向问题。最近，朋友Z 向我求助说，他一看到 this 的题目就犯难，搞不清楚 this 究竟指向了谁。我为他做了解答，并整理成了这篇文章，希望能帮到有需要的同学。\n            ")]),s._v(" "),v("h2",[s._v("一道面试题")]),s._v(" "),v("p",[s._v("\n                朋友Z 给我看了这样一道题：\n                "),v("pre",{staticClass:"hljs javascript"},[v("code",{},[v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" length = "),v("span",{staticClass:"hljs-number"},[s._v("10")]),s._v(";"),v("br"),v("br"),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("fn")]),s._v(" ("),v("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".length);"),v("br"),s._v("}"),v("br"),s._v(" "),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" obj = {"),v("br"),s._v("    "),v("span",{staticClass:"hljs-attr"},[s._v("length")]),s._v(": "),v("span",{staticClass:"hljs-number"},[s._v("5")]),s._v(","),v("br"),s._v("    "),v("span",{staticClass:"hljs-attr"},[s._v("method")]),s._v(": "),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),v("span",{staticClass:"hljs-params"},[s._v("fn")]),s._v(") ")]),s._v("{"),v("br"),s._v("        fn();"),v("br"),s._v("        "),v("span",{staticClass:"hljs-built_in"},[s._v("arguments")]),s._v("["),v("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("]();"),v("br"),s._v("    }"),v("br"),s._v("};"),v("br"),s._v(" "),v("br"),s._v("obj.method(fn, "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(");")])]),s._v("\n                问：浏览器的输出结果是什么？\n            ")]),s._v(" "),v("p",[s._v("\n                它的答案是：先输出一个 "),v("code",[s._v("10")]),s._v("，然后输出一个 "),v("code",[s._v("2")]),s._v("。\n            ")]),s._v(" "),v("p",[s._v("\n                让我们来看一下，这道题的解析：\n                "),v("ul",[v("li",[s._v("\n                        请牢记一个重要的原则："),v("strong",[s._v("this 永远指向，调用函数的那个对象")]),s._v("。\n                    ")]),s._v(" "),v("li",[s._v("\n                        在我们这道题中，虽然 fn 作为 method 的参数传了进来，但它的调用者并不受影响，任然是 "),v("strong",[s._v("window")]),s._v("，所以输出了 10.\n                    ")]),s._v(" "),v("li",[v("strong",[s._v("arguments[0]();")]),s._v(" 这条语句并不常见，可能大家有疑惑的点在这里。 其实，"),v("strong",[s._v("arguments 是一种特殊的对象。在函数中，我们无需指出参数名，就能访问。可以认为它是一种，隐式的传参形式")]),s._v("。\n                    ")]),s._v(" "),v("li",[s._v("\n                        当执行 arguments[0](); 时，其实调用了 fn()。而这时，fn 函数中 this 就指向了 arguments，这个特殊的对象。obj.method 方法接收了 2 个参数，所以 arguments 的 length，很显然就是 2 了。\n                    ")])])]),s._v(" "),v("h2",[s._v("改造一下")]),s._v(" "),v("p",[s._v("\n                再来，不少同学对 this 的指向感到疑惑，是因为 this 并没有指向我们预期的那个对象。\n            ")]),s._v(" "),v("p",[s._v("\n                就像这道题，从语义上来看，我们期望 fn() 输出的是 obj 自己的 length，也就是 5，而不是 10。那么如果要得到 5 的结果，我们该如何修改这段代码呢？\n            ")]),s._v(" "),v("p",[s._v("\n                其实只要多做一步处理就好。就是让 this 指向 obj 自己。这里，我们可以用 "),v("strong",[s._v("call")]),s._v(" 来改变 this 的指向，像下面这样：\n                "),v("pre",{staticClass:"hljs javascript"},[v("code",{},[v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" length = "),v("span",{staticClass:"hljs-number"},[s._v("10")]),s._v(";"),v("br"),v("br"),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("fn")]),s._v(" ("),v("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".length);"),v("br"),s._v("}"),v("br"),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" obj = {"),v("br"),s._v("    "),v("span",{staticClass:"hljs-attr"},[s._v("length")]),s._v(": "),v("span",{staticClass:"hljs-number"},[s._v("5")]),s._v(","),v("br"),s._v("    "),v("span",{staticClass:"hljs-attr"},[s._v("method")]),s._v(": "),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),v("span",{staticClass:"hljs-params"},[s._v("fn")]),s._v(") ")]),s._v("{"),v("br"),s._v("        "),v("span",{staticClass:"hljs-comment"},[s._v("// 在这里用call 将 this 指向 obj 自己")]),v("br"),s._v("        fn.call("),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(");"),v("br"),s._v("    }"),v("br"),s._v("};"),v("br"),s._v(" "),v("br"),s._v("obj.method(fn);")])]),s._v("\n                输出的结果就是 5 了，搞定。\n            ")]),s._v(" "),v("p",[s._v("\n                其实 this 也没那么复杂吧，我们只需要一些简单的操作，就能控制 this 的指向了。那么，问题来了，为什么有时候 this 会失控呢？\n            ")]),s._v(" "),v("p",[s._v("\n                别急，让我们从理解 this 的基本概念开始，来看看 this 到底是什么？\n            ")]),s._v(" "),v("h2",[s._v("this 是什么？")]),s._v(" "),v("p",[s._v("\n                this 是 JavaScript 中的一个关键字。它通常被运用于函数体内，依赖于函数调用的上下文条件，与函数被调用的方式有关。它指向谁，则完全是由函数被调用的调用点来决定的。\n            ")]),s._v(" "),v("p",[s._v("\n                所以，this，是在运行时绑定的，而与编写时的绑定无关。随着函数使用场合的不同，this 的值也会发生变化。但是有一个总的原则：那就是"),v("strong",[s._v("this 总会指向，调用函数的那个对象")]),s._v("。\n            ")]),s._v(" "),v("h2",[s._v("为什么要用this？")]),s._v(" "),v("p",[s._v("\n                从概念上理解起来，似乎有点费劲。那我们为什么还要使用 this 呢？用了 this 会带来什么好处？\n            ")]),s._v(" "),v("p",[s._v("\n                让我们先看下面这个例子：\n                "),v("pre",{staticClass:"hljs actionscript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("identify")]),v("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" ")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name.toUpperCase();"),v("br"),s._v("}"),v("br"),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" me = {"),v("br"),s._v("    name: "),v("span",{staticClass:"hljs-string"},[s._v('"Kyle"')]),v("br"),s._v("};"),v("br"),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" you = {"),v("br"),s._v("    name: "),v("span",{staticClass:"hljs-string"},[s._v('"Reader"')]),v("br"),s._v("};"),v("br"),v("br"),s._v("identify.call( me ); "),v("span",{staticClass:"hljs-comment"},[s._v("// KYLE")]),v("br"),s._v("identify.call( you ); "),v("span",{staticClass:"hljs-comment"},[s._v("// READER")])])]),s._v(" "),v("p",[s._v("\n                一开始我们可能太不明白为何这样输出。那不如先换个思路，与使用 this 相反，我们可以明确地将环境对象，传递给 identify()。像这样：\n                "),v("pre",{staticClass:"hljs actionscript"},[v("code",{},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("identify")]),v("span",{staticClass:"hljs-params"},[s._v("(context)")]),s._v(" ")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" context.name.toUpperCase();"),v("br"),s._v("}"),v("br"),s._v("identify( you ); "),v("span",{staticClass:"hljs-comment"},[s._v("// READER")])])])]),s._v(" "),v("p",[s._v("\n               在这个简单的例子中，结果是一样的。我们可以把环境对象直接传入函数，这样看来比较直观。但是，"),v("strong",[s._v("当模式越发复杂时，将执行环境作为一个明确的参数传递给函数，就会显得非常混乱了")]),s._v("。\n            ")]),s._v(" "),v("p",[s._v("\n                而 this 机制，可以提供一种更优雅的方式，来隐含地“传递”一个对象的引用，这会使得 API 的设计更加地干净，复用也会变得容易。\n            ")]),s._v(" "),v("h2",[s._v("this 的原理")]),s._v(" "),v("p",[s._v("\n                在明白了 this 的概念之后，不经让我好奇，为何 this 指向的就是函数运的执行环境呢？\n            ")]),s._v(" "),v("p",[s._v("\n                之前，看到了 "),v("strong",[s._v("阮老师")]),s._v(" 的一篇文章，十分透彻地分析了 this 的原理。我根据自己的理解，整理如下。\n            ")]),s._v(" "),v("p",[s._v("\n                很多教科书会告诉你，this 指的是函数运行时所在的环境。但是，为什么会这样？也就是说，函数的运行环境到底是怎么决定的？\n            ")]),s._v(" "),v("p",[s._v("\n                理解 this 的原理，有助于帮我们更好地理解它的用法。"),v("strong",[s._v("JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系")]),s._v("。\n            ")]),s._v(" "),v("p",[s._v("\n                来看一个简单的示例：\n                "),v("pre",{staticClass:"hljs javascript"},[v("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[v("span",{staticClass:"hljs-attribute"},[s._v("var obj")]),s._v(" = { foo:  5 };")])]),s._v("\n                上面的代码将一个对象赋值给变量 obj。JavaScript 引擎会先在内存里面，生成一个对象 { foo: 5 }，然后把这个对象的"),v("strong",[s._v("内存地址")]),s._v("赋值给变量 obj。\n            ")]),s._v(" "),v("p",[s._v("\n                也就是说，变量 obj 其实只是一个地址。后面如果要读取 obj.foo，引擎先从 obj 拿到内存地址，然后再从该地址读出原始的对象，返回它的 foo 属性。\n            ")]),s._v(" "),v("p",[s._v("\n                这样的结构很清晰，但如果属性的值是一个函数，又会怎么样呢？比如这样：\n                "),v("pre",{staticClass:"hljs actionscript"},[v("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" obj = { foo: "),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" ")]),s._v("{} };")])])]),s._v(" "),v("p",[s._v("\n                这时，JavaScript 引擎会将函数单独保存在内存中，然后再将"),v("strong",[s._v("函数的地址")]),s._v("赋值给 foo 属性的 value 属性。\n                "),v("img",{attrs:{src:a("77Bc")}}),s._v("\n                可以看到，函数是一个单独的值(以地址形式赋值)，所以才可以在不同的环境中执行。\n            ")]),s._v(" "),v("p",[s._v("\n                又因为，JavaScript 允许在函数体内部，引用当前环境的其他变量。所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是"),v("strong",[s._v("在函数体内部，指代函数当前的运行环境")]),s._v("。\n            ")]),s._v(" "),v("h2",[s._v("this 的用法")]),s._v(" "),v("p",[s._v("\n                在理解了 this 的原理之后，我们用下面的 4 种情况，来讨论 this 的用法。同样来自 "),v("strong",[s._v("阮老师")]),s._v(" 给出的例子，个人觉得很具有代表性。\n            ")]),s._v(" "),v("h4",[s._v("1、纯粹的函数调用")]),s._v(" "),v("p",[s._v("\n                这是函数的最通常用法，属于全局性调用，因此 this 就代表全局对象 window。\n                "),v("pre",{staticClass:"hljs actionscript"},[v("code",{},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("test")]),v("span",{staticClass:"hljs-params"},[s._v("()")])]),s._v("{"),v("br"),s._v("　　"),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x = "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),v("br"),s._v("　　"),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x);"),v("br"),s._v("}"),v("br"),s._v("test(); "),v("span",{staticClass:"hljs-comment"},[s._v("// 1")])])])]),s._v(" "),v("h4",[s._v("2、作为对象方法的调用")]),s._v(" "),v("p",[s._v("\n                函数作为某个对象的方法调用，这时 this 就指这个上级对象。\n                "),v("pre",{staticClass:"hljs javascript"},[v("code",{},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("test")]),s._v("("),v("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x);"),v("br"),s._v("}"),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" o = {};"),v("br"),s._v("o.x = "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),v("br"),s._v("o.m = test;"),v("br"),s._v("o.m(); "),v("span",{staticClass:"hljs-comment"},[s._v("// 1")])])])]),s._v(" "),v("h4",[s._v("3、作为构造函数调用")]),s._v(" "),v("p",[s._v("\n                所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this 就指这个新对象。\n                "),v("pre",{staticClass:"hljs javascript"},[v("code",{},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("test")]),s._v("("),v("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x = "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),v("br"),s._v("}"),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" o = "),v("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" test();"),v("br"),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(o.x); "),v("span",{staticClass:"hljs-comment"},[s._v("// 1")])])])]),s._v(" "),v("h4",[s._v("4、apply调用")]),s._v(" "),v("p",[s._v("\n                apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指的就是这第一个参数。\n                "),v("pre",{staticClass:"hljs javascript"},[v("code",{},[v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" x = "),v("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(";"),v("br"),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("test")]),s._v("("),v("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),v("br"),s._v("    "),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x);"),v("br"),s._v("}"),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" o = {};"),v("br"),s._v("o.x = "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),v("br"),s._v("o.m = test;"),v("br"),s._v("o.m.apply(); "),v("span",{staticClass:"hljs-comment"},[s._v("//0")])])]),s._v("\n                apply() 的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。\n            ")]),s._v(" "),v("h4",[s._v("5、箭头函数")]),s._v(" "),v("p",[s._v("\n                ES6 中的箭头函数，在大部分情况下，使得 this 的指向，变得符合我们的预期。但有些时候，它也不是万能的，一不小心的话，this 同样会失控。\n            ")]),s._v(" "),v("p",[s._v("因为篇幅内容较多，我会另写一篇文章来介绍。")]),s._v(" "),v("h2",[s._v("另一道面试题")]),s._v(" "),v("p",[s._v("\n                最后，让我们来巩固一下 this 的概念和用法。来看一道面试题：\n                "),v("pre",{staticClass:"hljs kotlin"},[v("code",{staticClass:"focus"},[s._v("window."),v("span",{staticClass:"hljs-keyword"},[s._v("val")]),s._v(" = "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),v("br"),s._v(" "),v("br"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" obj = {"),v("br"),s._v("    "),v("span",{staticClass:"hljs-keyword"},[s._v("val")]),s._v(": "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(","),v("br"),s._v("    dbl: function () {"),v("br"),s._v("        "),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("."),v("span",{staticClass:"hljs-keyword"},[s._v("val")]),s._v(" *= "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("; "),v("br"),s._v("        "),v("span",{staticClass:"hljs-keyword"},[s._v("val")]),s._v(" *= "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";       "),v("br"),s._v("        console.log("),v("span",{staticClass:"hljs-string"},[s._v("'val:'")]),s._v(", "),v("span",{staticClass:"hljs-keyword"},[s._v("val")]),s._v(");"),v("br"),s._v("        console.log("),v("span",{staticClass:"hljs-string"},[s._v("'this.val:'")]),s._v(", "),v("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("."),v("span",{staticClass:"hljs-keyword"},[s._v("val")]),s._v(");"),v("br"),s._v("    }"),v("br"),s._v("};"),v("br"),v("br"),s._v(" "),v("span",{staticClass:"hljs-comment"},[s._v("// 说出下面的输出结果")]),v("br"),s._v(" obj.dbl();"),v("br"),s._v(" "),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" func = obj.dbl;"),v("br"),s._v(" func();")])]),s._v("\n                答案是输出："),v("code",[s._v("2 、 4 、 8 、 8 ")]),s._v("。\n            ")]),s._v(" "),v("p",[s._v("\n                解析：\n                "),v("ul",[v("li",[s._v("\n                        执行 obj.dbl(); 时， this.val 的 this 指向 obj，而下一行的 val 指向 window。所以，由 window.val 输出 2，obj.val 输出 4 。\n                    ")]),s._v(" "),v("li",[s._v("\n                        最后一行 func(); 的调用者是 window。 所以，现在的 this.val 的 this 指向 window。\n                    ")]),s._v(" "),v("li",[s._v("\n                        别忘了刚才的运算结果，window.val 已经是 2 了，所以现在 this.val *= 2; 的执行结果就是 4。\n                    ")]),s._v(" "),v("li",[s._v("\n                        val *= 2; 的执行结果，就是 8 了。 所以，最终的结果就是输出 8 和 8 。\n                    ")])])]),s._v(" "),v("h2",[s._v("总结")]),s._v(" "),v("p",[s._v("\n                this 指代了函数当前的运行环境，依赖于函数调用的上下文条件，在运行时才会进行绑定。请牢记总原则："),v("strong",[s._v("this 总会指向，调用函数的那个对象")]),s._v("。\n            ")]),s._v(" "),v("h2",[s._v("参考文献")]),s._v(" "),v("p",[v("ul",[v("li",[v("a",{attrs:{href:"https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes",target:"_blank"}},[s._v("this 与对象原型")])]),s._v(" "),v("li",[v("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2018/06/javascript-this.html",target:"_blank"}},[s._v("JavaScript 的 this 原理")])])])])])])],1)},[],!1,null,null,null);r.options.__file="how-to-use-this-in-javascript.vue";t.default=r.exports},PSh9:function(s,t,a){s.exports={default:a("AFnJ"),__esModule:!0}},Qi1R:function(s,t,a){"use strict";t.a={utf8ToB64:function(s){return window.btoa(unescape(encodeURIComponent(s)))},b64ToUtf8:function(s){return decodeURIComponent(escape(window.atob(s)))}}},tbIA:function(s,t,a){"use strict";var v=a("/Lgp"),n=a("phsM"),_=a("kBaS"),l=a("dCrc"),i=a("6wgB"),r=Object.assign;s.exports=!r||a("/Vl9")(function(){var s={},t={},a=Symbol(),v="abcdefghijklmnopqrst";return s[a]=7,v.split("").forEach(function(s){t[s]=s}),7!=r({},s)[a]||Object.keys(r({},t)).join("")!=v})?function(s,t){for(var a=l(s),r=arguments.length,o=1,c=n.f,e=_.f;r>o;)for(var h,p=i(arguments[o++]),j=c?v(p).concat(c(p)):v(p),b=j.length,C=0;b>C;)e.call(p,h=j[C++])&&(a[h]=p[h]);return a}:r}}]);