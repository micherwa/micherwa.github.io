(window.webpackJsonp=window.webpackJsonp||[]).push([["lKIv"],{lKIv:function(s,a,t){"use strict";t.r(a);var _={},v=t("psIG"),l=Object(v.a)(_,function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("div",{staticClass:"blog-container"},[t("BlogHeader"),s._v(" "),t("BlogContent",{attrs:{useCatalog:!0}},[t("div",{attrs:{slot:"content"},slot:"content"},[t("h2",[s._v("前言")]),s._v(" "),t("p",[s._v("\n                上一篇文章\n                "),t("a",{attrs:{href:"",target:"_blank"}},[s._v("「前端面试题系列8」数组去重(10 种浓缩版)")]),s._v("\n                的最后简单介绍了 lodash 中的数组去重方法 "),t("code",[s._v("_.uniq")]),s._v("，并指向了它源码的实现文件 "),t("code",[s._v("_.baseUniq")]),s._v("。它可以实现我们日常工作中的去重需求。\n            ")]),s._v(" "),t("p",[s._v("\n                今天要讲的是，我从 _.baseUniq 中学到的几个，都很基础却容易被忽略的知识点。\n            ")]),s._v(" "),t("h2",[s._v("三个 API")]),s._v(" "),t("p",[s._v("\n                让我们从三个功能相近的去重 API 讲起，他们分别是："),t("code",[s._v("_.uniq")]),s._v("、"),t("code",[s._v("_.uniqBy")]),s._v("、"),t("code",[s._v("_.uniqWith")]),s._v("。它们三个背后的实现，都是依托于 "),t("strong",[s._v(".internal")]),s._v(" 下的 "),t("code",[s._v("_.baseUniq")]),s._v(" 文件。\n            ")]),s._v(" "),t("p",[s._v("\n                区别在于 _.uniq 只需传入一个源数组 array， _.uniqBy 相较于 _.uniq 要多传一个迭代器 "),t("code",[s._v("iteratee")]),s._v("，而 _.uniqWith 要多传一个比较器 "),t("code",[s._v("comparator")]),s._v("。iteratee 和 comparator 有什么用？之后会说到。\n            ")]),s._v(" "),t("p",[s._v("\n                以 _.uniqWith 为例，它是这样调用 _.baseUniq 的：\n                "),t("pre",{staticClass:"hljs actionscript"},[t("code",{},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("uniqWith")]),t("span",{staticClass:"hljs-params"},[s._v("(array, comparator)")]),s._v(" ")]),s._v("{"),t("br"),s._v("  comparator = "),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" comparator == "),t("span",{staticClass:"hljs-string"},[s._v("'function'")]),s._v(" ? comparator : "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" (array != "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" && array.length)"),t("br"),s._v("    ? baseUniq(array, "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", comparator)"),t("br"),s._v("    : []"),t("br"),s._v("}")])])]),s._v(" "),t("h2",[s._v("_.baseUniq 的实现")]),s._v(" "),t("p",[s._v("\n                baseUniq 的源码并不多，但比较绕。先贴一下的源码。\n                "),t("pre",{staticClass:"hljs cs"},[t("code",{},[s._v("const LARGE_ARRAY_SIZE = 200"),t("br"),t("br"),t("span",{staticClass:"hljs-function"},[s._v("function "),t("span",{staticClass:"hljs-title"},[s._v("baseUniq")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("array, iteratee, comparator")]),s._v(")")]),s._v(" {"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),t("span",{staticClass:"hljs-number"},[s._v("-1")]),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" includes = arrayIncludes"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),t("br"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" { length } = array"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" result = []"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" seen = "),t("span",{staticClass:"hljs-function"},[s._v("result")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[s._v("  "),t("span",{staticClass:"hljs-title"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("comparator")]),s._v(")")]),s._v(" {"),t("br"),s._v("    isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("    includes = arrayIncludesWith"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (length >= LARGE_ARRAY_SIZE) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" = iteratee ? "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" : createSet(array)"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(") {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" setToArray("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("    isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("    includes = cacheHas"),t("br"),s._v("    seen = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" SetCache"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {"),t("br"),s._v("    seen = iteratee ? [] : result"),t("br"),s._v("  }"),t("br"),s._v("  outer:"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++index < length) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = array[index]"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" computed = iteratee ? iteratee("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") : "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = (comparator || "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" !== "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") ? "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" : "),t("span",{staticClass:"hljs-number"},[s._v("0")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (isCommon && computed === computed) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" seenIndex = seen."),t("span",{staticClass:"hljs-function"},[s._v("length")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("      "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("seenIndex--")]),s._v(")")]),s._v(" {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (seen[seenIndex] === computed) {"),t("br"),s._v("          "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("        }"),t("br"),s._v("      }"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (iteratee) {"),t("br"),s._v("        seen.push(computed)"),t("br"),s._v("      }"),t("br"),s._v("      result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!includes(seen, computed, comparator)) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (seen !== result) {"),t("br"),s._v("        seen.push(computed)"),t("br"),s._v("      }"),t("br"),s._v("      result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" result"),t("br"),s._v("}")])]),s._v("\n                为了兼容刚才说的三个 API，就产生了不少的干扰项。如果先从 _.uniq 入手，去掉 iteratee 和 comparator 的干扰，就会清晰不少。\n                "),t("pre",{staticClass:"hljs cs"},[t("code",{},[t("span",{staticClass:"hljs-function"},[s._v("function "),t("span",{staticClass:"hljs-title"},[s._v("baseUniq")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("array")]),s._v(")")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),t("span",{staticClass:"hljs-number"},[s._v("-1")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" { length } = array"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" result = []"),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (length >= "),t("span",{staticClass:"hljs-number"},[s._v("200")]),s._v(") {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" = createSet(array)"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" setToArray("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(")"),t("br"),s._v("    }"),t("br"),t("br"),s._v("    outer:"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++index < length) {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = array[index]"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" === "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") {"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" resultIndex = result."),t("span",{staticClass:"hljs-function"},[s._v("length")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("            "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("resultIndex--")]),s._v(")")]),s._v(" {"),t("br"),s._v("                "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (result[resultIndex] === "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") {"),t("br"),s._v("                    "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("                }"),t("br"),s._v("            }"),t("br"),s._v("            result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("        } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!includes(seen, "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")) {"),t("br"),s._v("            result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" result"),t("br"),s._v("}")])]),s._v("\n                这里有 2 个知识点。\n            ")]),s._v(" "),t("h4",[s._v("知识点一、NaN === NaN 吗？")]),s._v(" "),t("p",[s._v("\n                在源码中有一个判断 "),t("code",[s._v("value === value")]),s._v("，乍一看，会觉得这是句废话！？！但其实，这是为了过滤 "),t("code",[s._v("NaN")]),s._v(" 的情况。\n            ")]),s._v(" "),t("p",[s._v("\n                MDN 中对 NaN 的解释是：它一个全局对象的属性，初始值就是 NaN。它通常都是在计算失败时，作为 Math 的某个方法的返回值出现的。\n            ")]),s._v(" "),t("p",[s._v("\n                判断一个值是否是 NaN，必须使用 Number.isNaN() 或 isNaN()，在执行自比较之中：NaN，也只有 NaN，比较之中不等于它自己。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(" === "),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(";        "),t("span",{staticClass:"hljs-comment"},[s._v("// false")]),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("Number")]),s._v(".NaN === "),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v("; "),t("span",{staticClass:"hljs-comment"},[s._v("// false")]),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("isNaN")]),s._v("("),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(");         "),t("span",{staticClass:"hljs-comment"},[s._v("// true")]),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("isNaN")]),s._v("("),t("span",{staticClass:"hljs-built_in"},[s._v("Number")]),s._v(".NaN);  "),t("span",{staticClass:"hljs-comment"},[s._v("// true")])])]),s._v("\n                当遇到 "),t("code",[s._v("NaN")]),s._v(" 的情况时，baseUniq 会转而去执行 "),t("code",[s._v("!includes(seen, value)")]),s._v(" 的判断\n            ")]),s._v(" "),t("h4",[s._v("知识点二、冒号的特殊作用")]),s._v(" "),t("p",[s._v("\n                在源码的主体部分，while 语句之前，有一行 "),t("code",[s._v("outer:")]),s._v("，它是干什么用的呢？ while 中还有一个 while 的内部，有一行 "),t("code",[s._v("continue outer")]),s._v("，从语义上理解，好像是继续执行 "),t("code",[s._v("outer")]),s._v("，这又是种什么写法呢？\n                "),t("pre",{staticClass:"hljs perl"},[t("code",{},[s._v("outer:"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++"),t("span",{staticClass:"hljs-keyword"},[s._v("index")]),s._v(" < "),t("span",{staticClass:"hljs-keyword"},[s._v("length")]),s._v(") {"),t("br"),s._v("    ..."),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (resultIndex--) {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (result[resultIndex] === value) {"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),s._v("}")])])]),s._v(" "),t("p",[s._v("\n                我们都知道 Javascript 中，常用到冒号的地方有三处，分别是："),t("strong",[s._v("A ? B : C 三元操作符、switch case 语句中、对象的键值对组成")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                但其实还有一种并不常见的特殊作用："),t("code",[t("strong",[s._v("标签语句")])]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                在 Javascript 中，任何语句都可以通过在它前面加上标志符和冒号来标记("),t("code",[s._v("identifier: statement")]),s._v(")，这样就可以在任何地方使用该标记，最常用于循环语句中。\n            ")]),s._v(" "),t("h2",[s._v("_.uniqBy 的 iteratee")]),s._v(" "),t("p",[s._v("\n                _.uniqBy 可根据指定的 key 给一个对象数组去重，一个官网的例子如下：\n                "),t("pre",{staticClass:"hljs perl"},[t("code",{},[s._v("// The "),t("span",{staticClass:"hljs-string"},[s._v("`_.property`")]),s._v(" iteratee shorthand."),t("br"),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".uniqBy([{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }], "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(");"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" => [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }]")])]),s._v("\n                这里的 "),t("code",[s._v("'x'")]),s._v(" 是 "),t("code",[s._v("_.property('x')")]),s._v(" 的缩写，它指的就是 "),t("strong",[s._v("iteratee")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                从给出的例子和语义上看，还挺好理解的。但是为什么 _.property 就能实现对象数组的去重了呢？它又是如何实现的呢？\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-meta"},[s._v("@param")]),s._v(" {"),t("span",{staticClass:"hljs-built_in"},[s._v("Array")]),s._v("|"),t("span",{staticClass:"hljs-built_in"},[s._v("string")]),s._v("} path The path of the property to "),t("span",{staticClass:"hljs-keyword"},[s._v("get")]),s._v("."),t("br"),t("span",{staticClass:"hljs-meta"},[s._v("@returns")]),s._v(" {"),t("span",{staticClass:"hljs-built_in"},[s._v("Function")]),s._v("} Returns the "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" accessor "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(".")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("property")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("path")]),s._v(") ")]),s._v("{")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("  "),t("span",{staticClass:"hljs-title"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("isKey")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("path")]),s._v(") ? "),t("span",{staticClass:"hljs-title"},[s._v("baseProperty")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("toKey(path)")]),s._v(") : "),t("span",{staticClass:"hljs-title"},[s._v("basePropertyDeep")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("path")]),s._v(")")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("}")])])]),s._v("\n                从注释看，property 方法会返回一个 "),t("code",[s._v("Function")]),s._v("，再看 baseProperty 的实现：\n                "),t("pre",{staticClass:"hljs javascript"},[t("code",{},[s._v("@param {string} key The key "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" the property to get."),t("br"),s._v("@returns {"),t("span",{staticClass:"hljs-built_in"},[s._v("Function")]),s._v("} Returns the "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" accessor "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(".")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-title"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("baseProperty")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("key")]),s._v(") ")]),s._v("{"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("object")]),s._v(") =>")]),s._v(" object == "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" ? "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(" : object[key]"),t("br"),s._v("}")])]),s._v("\n                咦？怎么返回的还是个 "),t("code",[s._v("Function")]),s._v(" ？感觉它什么也没干呀，跟打酱油一样。。。\n            ")]),s._v(" "),t("h4",[s._v("知识点三、纯函数的概念")]),s._v(" "),t("p",[s._v("\n                纯函数，是函数式编程中的概念，它代表这样一类函数："),t("strong",[s._v("对于指定输出，返回指定的结果。不存在副作用")]),s._v("。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-comment"},[s._v("// 这是一个简单的纯函数")]),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" addByOne = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("x")]),s._v(" =>")]),s._v(" x + "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";")])]),s._v("\n                也就是说，纯函数的返回值只依赖其参数，函数体内不能存在任何副作用。如果是同样的参数，则一定能得到一致的返回结果。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-function"}),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-title"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("baseProperty")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("key")]),s._v(") ")]),s._v("{"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("object")]),s._v(") =>")]),s._v(" object == "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" ? "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(" : object[key]"),t("br"),s._v("}")])])]),s._v(" "),t("p",[s._v("\n                baseProperty 返回的就是一个纯函数，在符合条件的情况下，输出 "),t("code",[s._v("object[key]")]),s._v("。在函数式编程中，函数是“一等公民”，它可以只是根据参数，做简单的组合操作，再作为别的函数的返回值。\n            ")]),s._v(" "),t("h2",[s._v("_.uniqWith 的 comparator")]),s._v(" "),t("p",[s._v("\n                还是先从官网的小例子说起，它会完全地给对象中所有的键值对做比较。\n                "),t("pre",{staticClass:"hljs ruby"},[t("code",{},[s._v("var objects = [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }];"),t("br"),t("br"),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".uniqWith(objects, "),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".isEqual);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" => [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }]")])]),s._v("\n                而在 baseUniq 的源码中，可以看到最终的实现，需要依赖 arrayIncludesWith 方法。\n                "),t("pre",{staticClass:"hljs php"},[t("code",{},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("arrayIncludesWith")]),t("span",{staticClass:"hljs-params"},[s._v("(array, target, comparator)")]),s._v(" ")]),s._v("{"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("array")]),s._v(" == "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v(") {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),t("br"),s._v("  }"),t("br"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" value of "),t("span",{staticClass:"hljs-keyword"},[s._v("array")]),s._v(") {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (comparator(target, value)) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("true")]),t("br"),s._v("    }"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),t("br"),s._v("}")])]),s._v("\n                这里没什么复杂吧。comparator 作为一个参数传入，将 target 和 array 的每个 value 进行处理。如果用官网的例子看，那就是比较它们是否相等。\n            ")]),s._v(" "),t("p",[s._v("\n                接着就追溯到了 _.isEqual 的源码，它的实现文件是 baseIsEqualDeep.js。在里面看到一个有点绕的写法，这是一个判断。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-comment"},[s._v("/** Used to check objects for own properties. */")]),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" hasOwnProperty = "),t("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v(".prototype.hasOwnProperty"),t("br"),s._v("..."),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" objIsWrapped = objIsObj && hasOwnProperty.call(object, "),t("span",{staticClass:"hljs-string"},[s._v("'__wrapped__'")]),s._v(")")])]),s._v("\n                hasOwnProperty ？call ？ '__wrapped__' ？\n            ")]),s._v(" "),t("h4",[s._v("知识点四、对象的 hasOwnProperty")]),s._v(" "),t("p",[s._v("\n                所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。它可以用来检测一个对象是否含有特定的自身属性；会忽略掉那些从原型链上继承到的属性。\n                "),t("pre",{staticClass:"hljs ruby"},[t("code",{},[s._v("o = new Object();"),t("br"),s._v("o.prop = "),t("span",{staticClass:"hljs-string"},[s._v("'exists'")]),s._v(";"),t("br"),s._v("o.hasOwnProperty("),t("span",{staticClass:"hljs-string"},[s._v("'prop'")]),s._v(");             "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 返回 "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),t("br"),s._v("o.hasOwnProperty("),t("span",{staticClass:"hljs-string"},[s._v("'toString'")]),s._v(");         "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 返回 "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("o.hasOwnProperty("),t("span",{staticClass:"hljs-string"},[s._v("'hasOwnProperty'")]),s._v(");   "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 返回 "),t("span",{staticClass:"hljs-literal"},[s._v("false")])])]),s._v("\n                call 的用法可以参考这篇 "),t("a",{attrs:{href:"https://juejin.im/post/5c493086f265da6115111ce4",target:"_blank"}},[s._v("细说 call、apply 以及 bind 的区别和用法")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                那么 "),t("code",[s._v("hasOwnProperty.call(object, '__wrapped__')")]),s._v(" 的意思就是，判断 object 这个对象上是否存在 '__wrapped__' 这个自身属性。\n            ")]),s._v(" "),t("p",[s._v("\n                __wrapped__ 是什么属性？这就要说到 lodash 的延迟计算方法 "),t("code",[s._v("_.chain")]),s._v("，它是一种函数式风格，从名字就可以看出可以实现一种链式的写法。比如下面这个例子：\n                "),t("pre",{staticClass:"hljs actionscript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" names = _.chain(users)"),t("br"),s._v("  .map("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),t("span",{staticClass:"hljs-params"},[s._v("(user)")])]),s._v("{"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" user.user;"),t("br"),s._v("  })"),t("br"),s._v("  .join("),t("span",{staticClass:"hljs-string"},[s._v('" , "')]),s._v(")"),t("br"),s._v("  .value();")])]),s._v("\n                如果你没有显样的调用value方法，使其立即执行的话，将会得到如下的LodashWrapper延迟表达式：\n                "),t("pre",{staticClass:"hljs groovy"},[t("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[s._v("LodashWrapper {"),t("span",{staticClass:"hljs-string"},[s._v("__wrapped__:")]),s._v(" LazyWrapper, "),t("span",{staticClass:"hljs-string"},[s._v("__actions__:")]),s._v(" Array["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("], "),t("span",{staticClass:"hljs-string"},[s._v("__chain__:")]),s._v(" "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("constructor:")]),s._v(" function, "),t("span",{staticClass:"hljs-string"},[s._v("after:")]),s._v(" function…}")])]),s._v("\n                因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后知道我们需要使用的时候，使用value显式立即执行即可。\n            ")]),s._v(" "),t("h2",[s._v("总结")]),s._v(" "),t("p",[s._v("\n                源码的阅读一开始会比较困难，因为会遇到看不明白的写法，所以还是要不断地夯实基础知识，遇到看不明白的点，就多查多问。\n            ")]),s._v(" "),t("p",[s._v("\n                就比如一开始我不明白 value === value 的写法有什么意义，一旦明白了是为了过滤 NaN 用的，那后面就会通畅很多了。\n            ")])])])],1)},[],!1,null,null,null);l.options.__file="uniq-in-lodash.vue";a.default=l.exports}}]);