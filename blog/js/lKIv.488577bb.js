(window.webpackJsonp=window.webpackJsonp||[]).push([["lKIv"],{lKIv:function(s,a,t){"use strict";t.r(a);var _={},v=t("psIG"),l=Object(v.a)(_,function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("div",{staticClass:"blog-container"},[t("BlogHeader"),s._v(" "),t("BlogContent",{attrs:{useCatalog:!0}},[t("div",{attrs:{slot:"content"},slot:"content"},[t("h2",[s._v("前言")]),s._v(" "),t("p",[s._v("\n                上一篇文章\n                "),t("a",{attrs:{href:"",target:"_blank"}},[s._v("「前端面试题系列8」数组去重(10 种浓缩版)")]),s._v("\n                的最后，简单介绍了 lodash 中的数组去重方法 "),t("code",[s._v("_.uniq")]),s._v("，它可以实现我们日常工作中的去重需求，能够去重 "),t("code",[s._v("NaN")]),s._v("，并保留 "),t("code",[s._v("{...}")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                今天要讲的，是我从 _.uniq 的源码实现文件 baseUniq.js 中学到的几个很基础，却又容易被忽略的知识点。\n            ")]),s._v(" "),t("h2",[s._v("三个 API")]),s._v(" "),t("p",[s._v("\n                让我们先从三个功能相近的 API 讲起，他们分别是："),t("code",[s._v("_.uniq")]),s._v("、"),t("code",[s._v("_.uniqBy")]),s._v("、"),t("code",[s._v("_.uniqWith")]),s._v("。它们三个背后的实现文件，都指向了 "),t("strong",[s._v(".internal")]),s._v(" 下的 "),t("strong",[s._v("baseUniq.js")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                区别在于 _.uniq 只需传入一个源数组 array， _.uniqBy 相较于 _.uniq 要多传一个迭代器 "),t("code",[s._v("iteratee")]),s._v("，而 _.uniqWith 要多传一个比较器 "),t("code",[s._v("comparator")]),s._v("。iteratee 和 comparator 的用法，会在后面说到。\n            ")]),s._v(" "),t("p",[s._v("\n                以 _.uniqWith 为例，它是这样调用 _.baseUniq 的：\n                "),t("pre",{staticClass:"hljs actionscript"},[t("code",{},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("uniqWith")]),t("span",{staticClass:"hljs-params"},[s._v("(array, comparator)")]),s._v(" ")]),s._v("{"),t("br"),s._v("  comparator = "),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" comparator == "),t("span",{staticClass:"hljs-string"},[s._v("'function'")]),s._v(" ? comparator : "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" (array != "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" && array.length)"),t("br"),s._v("    ? baseUniq(array, "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", comparator)"),t("br"),s._v("    : []"),t("br"),s._v("}")])])]),s._v(" "),t("h2",[s._v("baseUniq 的实现原理")]),s._v(" "),t("p",[s._v("\n                baseUniq 的源码并不多，但比较绕。先贴一下的源码。\n                "),t("pre",{staticClass:"hljs cs"},[t("code",{},[s._v("const LARGE_ARRAY_SIZE = 200"),t("br"),t("br"),t("span",{staticClass:"hljs-function"},[s._v("function "),t("span",{staticClass:"hljs-title"},[s._v("baseUniq")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("array, iteratee, comparator")]),s._v(")")]),s._v(" {"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),t("span",{staticClass:"hljs-number"},[s._v("-1")]),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" includes = arrayIncludes"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),t("br"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" { length } = array"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" result = []"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" seen = "),t("span",{staticClass:"hljs-function"},[s._v("result")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[s._v("  "),t("span",{staticClass:"hljs-title"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("comparator")]),s._v(")")]),s._v(" {"),t("br"),s._v("    isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("    includes = arrayIncludesWith"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (length >= LARGE_ARRAY_SIZE) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" = iteratee ? "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" : createSet(array)"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(") {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" setToArray("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("    isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("    includes = cacheHas"),t("br"),s._v("    seen = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" SetCache"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {"),t("br"),s._v("    seen = iteratee ? [] : result"),t("br"),s._v("  }"),t("br"),s._v("  outer:"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++index < length) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = array[index]"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" computed = iteratee ? iteratee("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") : "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = (comparator || "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" !== "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") ? "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" : "),t("span",{staticClass:"hljs-number"},[s._v("0")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (isCommon && computed === computed) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" seenIndex = seen."),t("span",{staticClass:"hljs-function"},[s._v("length")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("      "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("seenIndex--")]),s._v(")")]),s._v(" {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (seen[seenIndex] === computed) {"),t("br"),s._v("          "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("        }"),t("br"),s._v("      }"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (iteratee) {"),t("br"),s._v("        seen.push(computed)"),t("br"),s._v("      }"),t("br"),s._v("      result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!includes(seen, computed, comparator)) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (seen !== result) {"),t("br"),s._v("        seen.push(computed)"),t("br"),s._v("      }"),t("br"),s._v("      result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" result"),t("br"),s._v("}")])]),s._v("\n                为了兼容刚才说的三个 API，就产生了不少的干扰项。如果先从 _.uniq 入手，去掉 iteratee 和 comparator 的干扰，就会清晰不少。\n                "),t("pre",{staticClass:"hljs cs"},[t("code",{},[t("span",{staticClass:"hljs-function"},[s._v("function "),t("span",{staticClass:"hljs-title"},[s._v("baseUniq")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("array")]),s._v(")")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),t("span",{staticClass:"hljs-number"},[s._v("-1")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" { length } = array"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" result = []"),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (length >= "),t("span",{staticClass:"hljs-number"},[s._v("200")]),s._v(") {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" = createSet(array)"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" setToArray("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(")"),t("br"),s._v("    }"),t("br"),t("br"),s._v("    outer:"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++index < length) {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = array[index]"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" === "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") {"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" resultIndex = result."),t("span",{staticClass:"hljs-function"},[s._v("length")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("            "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("resultIndex--")]),s._v(")")]),s._v(" {"),t("br"),s._v("                "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (result[resultIndex] === "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") {"),t("br"),s._v("                    "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("                }"),t("br"),s._v("            }"),t("br"),s._v("            result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("        } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!includes(seen, "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")) {"),t("br"),s._v("            result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" result"),t("br"),s._v("}")])]),s._v("\n                这里有 2 个知识点。\n            ")]),s._v(" "),t("h4",[s._v("知识点一、NaN === NaN 吗？")]),s._v(" "),t("p",[s._v("\n                在源码中有一个判断 "),t("code",[s._v("value === value")]),s._v("，乍一看，会觉得这是句废话！？！但其实，这是为了过滤 "),t("code",[s._v("NaN")]),s._v(" 的情况。\n            ")]),s._v(" "),t("p",[s._v("\n                MDN 中对 NaN 的解释是：它是一个全局对象的属性，初始值就是 NaN。它通常都是在计算失败时，作为 Math 的某个方法的返回值出现的。\n            ")]),s._v(" "),t("p",[s._v("\n                判断一个值是否是 NaN，必须使用 "),t("strong",[s._v("Number.isNaN()")]),s._v(" 或 "),t("strong",[s._v("isNaN()")]),s._v("，在执行自比较之中：NaN，也只有 NaN，比较之中不等于它自己。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(" === "),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(";        "),t("span",{staticClass:"hljs-comment"},[s._v("// false")]),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("Number")]),s._v(".NaN === "),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v("; "),t("span",{staticClass:"hljs-comment"},[s._v("// false")]),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("isNaN")]),s._v("("),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(");         "),t("span",{staticClass:"hljs-comment"},[s._v("// true")]),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("isNaN")]),s._v("("),t("span",{staticClass:"hljs-built_in"},[s._v("Number")]),s._v(".NaN);  "),t("span",{staticClass:"hljs-comment"},[s._v("// true")])])]),s._v("\n                所以，在源码中，当遇到 "),t("code",[s._v("NaN")]),s._v(" 的情况时，baseUniq 会转而去执行 "),t("code",[s._v("!includes(seen, value)")]),s._v(" 的判断，去处理 NaN 。\n            ")]),s._v(" "),t("h4",[s._v("知识点二、冒号的特殊作用")]),s._v(" "),t("p",[s._v("\n                在源码的主体部分，while 语句之前，有一行 "),t("code",[s._v("outer:")]),s._v("，它是干什么用的呢？ while 中还有一个 while 的内部，有一行 "),t("code",[s._v("continue outer")]),s._v("，从语义上理解，好像是继续执行 "),t("code",[s._v("outer")]),s._v("，这又是种什么写法呢？\n                "),t("pre",{staticClass:"hljs perl"},[t("code",{},[s._v("outer:"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++"),t("span",{staticClass:"hljs-keyword"},[s._v("index")]),s._v(" < "),t("span",{staticClass:"hljs-keyword"},[s._v("length")]),s._v(") {"),t("br"),s._v("    ..."),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (resultIndex--) {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (result[resultIndex] === value) {"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),s._v("}")])])]),s._v(" "),t("p",[s._v("\n                我们都知道 Javascript 中，常用到冒号的地方有三处，分别是："),t("strong",[s._v("A ? B : C 三元操作符、switch case 语句中、对象的键值对组成")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                但其实还有一种并不常见的特殊作用："),t("code",[t("strong",[s._v("标签语句")])]),s._v("。在 Javascript 中，任何语句都可以通过在它前面加上标志符和冒号来标记("),t("code",[s._v("identifier: statement")]),s._v(")，这样就可以在任何地方使用该标记，最常用于循环语句中。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，在源码中，outer 只是看着有点不习惯，多看两遍就好了，语义上还是很好理解的。\n            ")]),s._v(" "),t("h2",[s._v("_.uniqBy 的 iteratee")]),s._v(" "),t("p",[s._v("\n                _.uniqBy 可根据指定的 key 给一个对象数组去重，一个官网的例子如下：\n                "),t("pre",{staticClass:"hljs perl"},[t("code",{},[s._v("// The "),t("span",{staticClass:"hljs-string"},[s._v("`_.property`")]),s._v(" iteratee shorthand."),t("br"),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".uniqBy([{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }], "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(");"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" => [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }]")])]),s._v("\n                这里的 "),t("code",[s._v("'x'")]),s._v(" 是 "),t("code",[s._v("_.property('x')")]),s._v(" 的缩写，它指的就是 "),t("strong",[s._v("iteratee")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                从给出的例子和语义上看，还挺好理解的。但是为什么 _.property 就能实现对象数组的去重了呢？它又是如何实现的呢？\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-meta"},[s._v("@param")]),s._v(" {"),t("span",{staticClass:"hljs-built_in"},[s._v("Array")]),s._v("|"),t("span",{staticClass:"hljs-built_in"},[s._v("string")]),s._v("} path The path of the property to "),t("span",{staticClass:"hljs-keyword"},[s._v("get")]),s._v("."),t("br"),t("span",{staticClass:"hljs-meta"},[s._v("@returns")]),s._v(" {"),t("span",{staticClass:"hljs-built_in"},[s._v("Function")]),s._v("} Returns the "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" accessor "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(".")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("property")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("path")]),s._v(") ")]),s._v("{")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("  "),t("span",{staticClass:"hljs-title"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("isKey")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("path")]),s._v(") ? "),t("span",{staticClass:"hljs-title"},[s._v("baseProperty")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("toKey(path)")]),s._v(") : "),t("span",{staticClass:"hljs-title"},[s._v("basePropertyDeep")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("path")]),s._v(")")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("}")])])]),s._v("\n                从注释看，property 方法会返回一个 "),t("code",[s._v("Function")]),s._v("，再看 baseProperty 的实现：\n                "),t("pre",{staticClass:"hljs javascript"},[t("code",{},[s._v("@param {string} key The key "),t("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" the property to get."),t("br"),s._v("@returns {"),t("span",{staticClass:"hljs-built_in"},[s._v("Function")]),s._v("} Returns the "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" accessor "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(".")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-title"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("baseProperty")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("key")]),s._v(") ")]),s._v("{"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("object")]),s._v(") =>")]),s._v(" object == "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" ? "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(" : object[key]"),t("br"),s._v("}")])]),s._v("\n                咦？怎么返回的还是个 "),t("code",[s._v("Function")]),s._v(" ？感觉它什么也没干呀，那个参数 "),t("code",[s._v("object")]),s._v(" 又是哪里来的？\n            ")]),s._v(" "),t("h4",[s._v("知识点三、纯函数的概念")]),s._v(" "),t("p",[s._v("\n                纯函数，是函数式编程中的概念，它代表这样一类函数："),t("strong",[s._v("对于指定输出，返回指定的结果。不存在副作用")]),s._v("。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-comment"},[s._v("// 这是一个简单的纯函数")]),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" addByOne = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("x")]),s._v(" =>")]),s._v(" x + "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";")])]),s._v("\n                也就是说，纯函数的返回值只依赖其参数，函数体内不能存在任何副作用。如果是同样的参数，则一定能得到一致的返回结果。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-function"}),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-title"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("baseProperty")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("key")]),s._v(") ")]),s._v("{"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("object")]),s._v(") =>")]),s._v(" object == "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" ? "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(" : object[key]"),t("br"),s._v("}")])])]),s._v(" "),t("p",[s._v("\n                baseProperty 返回的就是一个纯函数，在符合条件的情况下，输出 "),t("code",[s._v("object[key]")]),s._v("。在函数式编程中，函数是“一等公民”，它可以只是根据参数，做简单的组合操作，再作为别的函数的返回值。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，在源码中，object 是调用 baseProperty 时传入的对象。 baseProperty 的作用，是返回期望结果为 object[key] 的函数。\n            ")]),s._v(" "),t("h2",[s._v("_.uniqWith 的 comparator")]),s._v(" "),t("p",[s._v("\n                还是先从官网的小例子说起，它会完全地给对象中所有的键值对，进行比较。\n                "),t("pre",{staticClass:"hljs ruby"},[t("code",{},[s._v("var objects = [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }];"),t("br"),t("br"),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".uniqWith(objects, "),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".isEqual);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" => [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'y'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }]")])]),s._v("\n                而在 baseUniq 的源码中，可以看到最终的实现，需要依赖 "),t("code",[s._v("arrayIncludesWith")]),s._v(" 方法，以下是它的源码：\n                "),t("pre",{staticClass:"hljs php"},[t("code",{},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("arrayIncludesWith")]),t("span",{staticClass:"hljs-params"},[s._v("(array, target, comparator)")]),s._v(" ")]),s._v("{"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("array")]),s._v(" == "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v(") {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),t("br"),s._v("  }"),t("br"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" value of "),t("span",{staticClass:"hljs-keyword"},[s._v("array")]),s._v(") {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (comparator(target, value)) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("true")]),t("br"),s._v("    }"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),t("br"),s._v("}")])]),s._v("\n                arrayIncludesWith 没什么复杂的。comparator 作为一个参数传入，将 "),t("code",[s._v("target")]),s._v(" 和 array 的每个 "),t("code",[s._v("value")]),s._v(" 进行处理。从官网的例子看，_.isEqual 就是 comparator，就是要比较它们是否相等。\n            ")]),s._v(" "),t("p",[s._v("\n                接着就追溯到了 _.isEqual 的源码，它的实现文件是 baseIsEqualDeep.js。在里面看到一个让我犯迷糊的写法，这是一个判断。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-comment"},[s._v("/** Used to check objects for own properties. */")]),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" hasOwnProperty = "),t("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v(".prototype.hasOwnProperty"),t("br"),s._v("..."),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" objIsWrapped = objIsObj && hasOwnProperty.call(object, "),t("span",{staticClass:"hljs-string"},[s._v("'__wrapped__'")]),s._v(")")])]),s._v("\n                hasOwnProperty ？call， '__wrapped__' ？\n            ")]),s._v(" "),t("h4",[s._v("知识点四、对象的 hasOwnProperty")]),s._v(" "),t("p",[s._v("\n                再次查找到了 MDN 的解释：所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。它可以用来检测一个对象是否含有特定的自身属性；会忽略掉那些从原型链上继承到的属性。\n                "),t("pre",{staticClass:"hljs ruby"},[t("code",{},[s._v("o = new Object();"),t("br"),s._v("o.prop = "),t("span",{staticClass:"hljs-string"},[s._v("'exists'")]),s._v(";"),t("br"),s._v("o.hasOwnProperty("),t("span",{staticClass:"hljs-string"},[s._v("'prop'")]),s._v(");             "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 返回 "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),t("br"),s._v("o.hasOwnProperty("),t("span",{staticClass:"hljs-string"},[s._v("'toString'")]),s._v(");         "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 返回 "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("o.hasOwnProperty("),t("span",{staticClass:"hljs-string"},[s._v("'hasOwnProperty'")]),s._v(");   "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 返回 "),t("span",{staticClass:"hljs-literal"},[s._v("false")])])]),s._v("\n                call 的用法可以参考这篇 "),t("a",{attrs:{href:"https://juejin.im/post/5c493086f265da6115111ce4",target:"_blank"}},[s._v("细说 call、apply 以及 bind 的区别和用法")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                那么 "),t("code",[s._v("hasOwnProperty.call(object, '__wrapped__')")]),s._v(" 的意思就是，判断 object 这个对象上是否存在 '__wrapped__' 这个自身属性。\n            ")]),s._v(" "),t("p",[s._v("\n                __wrapped__ 是什么属性？这就要说到 lodash 的延迟计算方法 "),t("code",[s._v("_.chain")]),s._v("，它是一种函数式风格，从名字就可以看出，它实现的是一种链式的写法。比如下面这个例子：\n                "),t("pre",{staticClass:"hljs actionscript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" names = _.chain(users)"),t("br"),s._v("  .map("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),t("span",{staticClass:"hljs-params"},[s._v("(user)")])]),s._v("{"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" user.user;"),t("br"),s._v("  })"),t("br"),s._v("  .join("),t("span",{staticClass:"hljs-string"},[s._v('" , "')]),s._v(")"),t("br"),s._v("  .value();")])]),s._v("\n                如果你没有显样的调用value方法，使其立即执行的话，将会得到如下的LodashWrapper延迟表达式：\n                "),t("pre",{staticClass:"hljs groovy"},[t("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[s._v("LodashWrapper {"),t("span",{staticClass:"hljs-string"},[s._v("__wrapped__:")]),s._v(" LazyWrapper, "),t("span",{staticClass:"hljs-string"},[s._v("__actions__:")]),s._v(" Array["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("], "),t("span",{staticClass:"hljs-string"},[s._v("__chain__:")]),s._v(" "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("constructor:")]),s._v(" function, "),t("span",{staticClass:"hljs-string"},[s._v("after:")]),s._v(" function…}")])]),s._v("\n                因为延迟表达式的存在，因此我们可以多次增加方法链，但这并不会被执行，所以不会存在性能的问题，最后直到我们需要使用的时候，使用 "),t("code",[s._v("value()")]),s._v(" 显式立即执行即可。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，在 baseIsEqualDeep 源码中，才需要做 hasOwnProperty 的判断，然后在需要的情况下，执行 "),t("code",[s._v("object.value()")]),s._v("。\n            ")]),s._v(" "),t("h2",[s._v("总结")]),s._v(" "),t("p",[s._v("\n                阅读源码，在一开始会比较困难，因为会遇到一些看不明白的写法。就像一开始我卡在了 value === value 的写法，不明白它的用意。一旦知道了是为了过滤 NaN 用的，那后面就会通畅很多了。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，"),t("strong",[s._v("阅读源码，是一种很棒的重温基础知识的方式")]),s._v("。遇到看不明白的点，不要放过，多查多问多看，才能"),t("strong",[s._v("不断地夯实基础，读懂更多的源码思想，体会更多的原生精髓")]),s._v("。如果我在一开始看到 value === value 时就放弃了，那或许就不会有今天的这篇文章了。\n            ")])])])],1)},[],!1,null,null,null);l.options.__file="uniq-in-lodash.vue";a.default=l.exports}}]);