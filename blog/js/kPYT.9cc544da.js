(window.webpackJsonp=window.webpackJsonp||[]).push([["kPYT"],{kPYT:function(s,a,t){"use strict";t.r(a);var v={created:function(){}},n=t("psIG"),_=Object(n.a)(v,function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("div",{staticClass:"blog-container"},[t("BlogHeader",{attrs:{title:"Javascript中的异步编程",subTitle:"",date:"2017-11-06",tags:["Javascript"]}}),s._v(" "),t("BlogContent",{attrs:{useCatalog:!0}},[t("div",{attrs:{slot:"content"},slot:"content"},[t("h2",[s._v("前言")]),s._v(" "),t("p",[s._v("\n                最近，有个小伙伴问了我一段代码：\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" funB = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") =>")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v('"funB "')]),s._v("+ value);"),t("br"),s._v("};"),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" funA = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("callback")]),s._v(") =>")]),s._v(" {"),t("br"),s._v("    ..."),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" callback === "),t("span",{staticClass:"hljs-string"},[s._v('"function"')]),s._v(" && callback("),t("span",{staticClass:"hljs-string"},[s._v('"is_ok!"')]),s._v(");"),t("br"),s._v("}"),t("br"),t("br"),s._v("funA(funB);")])]),s._v("\n                他不太理解这段代码中，funB函数作为funA函数的参数这样的写法。从语义上看，callback的意思是回调，那么是说funB是funA的回调嘛？\n            ")]),s._v(" "),t("p",[s._v("\n                我看了一会说，是的，funB函数的确是funA函数的回调，它会等待funA中前面的语句都执行完，再去执行。这是一种异步编程的写法。\n            ")]),s._v(" "),t("p",[s._v("\n                嗯...额...等一下，异步编程，是什么？除了回调函数之外，还有什么？\n            ")]),s._v(" "),t("p",[s._v("\n                别急，让我们先从概念入手，再逐个理解异步编程中的方法，看看它的前世今生。\n            ")]),s._v(" "),t("h2",[s._v("什么是异步？")]),s._v(" "),t("p",[s._v('\n                所谓"异步"(Asynchronous)，可以理解为'),t("strong",[s._v("一种不连续的执行")]),s._v("。简单地说，就是把一个任务分成两段，先执行第一段，然后转而执行其他任务，等接到通知了，再回过头执行第二段。\n            ")]),s._v(" "),t("p",[s._v("\n                我们都知道，JavaScript是单线程的。而异步，对于JavaScript的重要性，则体现在"),t("strong",[s._v("非阻塞")]),s._v("这一点上。一些常见的异步有：\n                "),t("ul",[t("li",[t("code",[s._v("onclick")]),s._v(" 在其事件触发的时候，回调会立即添加到任务队列中。\n                    ")]),s._v(" "),t("li",[t("code",[s._v("setTimeout")]),s._v(" 只有当时间到达的时候，才会将回调添加到任务队列中。\n                    ")]),s._v(" "),t("li",[t("code",[s._v("ajax")]),s._v(" 在网络请求完成并返回之后，才将回调添加到任务队列中。\n                    ")])]),s._v("\n                接下来，我们一起来看看Javascript中的异步编程，具体有哪几种。\n            ")]),s._v(" "),t("h2",[s._v("实现异步编程的方法")]),s._v(" "),t("h4",[s._v("一、回调函数")]),s._v(" "),t("p",[s._v("\n                上面不止一次提到了回调函数。它从概念上说很简单，就是"),t("strong",[s._v("把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。")]),s._v("它是异步编程中，最基本的方法。\n            ")]),s._v(" "),t("p",[s._v("\n                举个例子，假定有两个函数 f1 和 f2，后者等待前者的执行结果。顺序执行的话，可以这样写：\n                "),t("pre",{staticClass:"hljs lisp"},[t("code",{},[s._v("f1()"),t("span",{staticClass:"hljs-comment"},[s._v(";")]),t("br"),s._v("f2()"),t("span",{staticClass:"hljs-comment"},[s._v(";")])])])]),s._v(" "),t("p",[s._v("但是，如果 f1 是一个很耗时的任务，该怎么办？")]),s._v(" "),t("p",[s._v("\n                改写一下 f1，把 f2 写成 f1 的回调函数：\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const f1 = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("(callback)")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("    setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" callback === "),t("span",{staticClass:"hljs-string"},[s._v('"function"')]),s._v(" && callback();"),t("br"),s._v("    }, "),t("span",{staticClass:"hljs-number"},[s._v("1000")]),s._v(");"),t("br"),s._v("}"),t("br"),s._v("f1(f2);")])]),s._v("\n                采用这种方式，我们就把同步操作变成了异步操作。f1 并不会堵塞整个程序的运行。相当于执行完 f1 之后，通过回调通知了 f2 的执行。\n            ")]),s._v(" "),t("p",[s._v("\n                它的优点是：简单、容易理解，写起来也简单。\n            ")]),s._v(" "),t("p",[s._v("\n                缺点是：不利于代码的阅读和维护，各个部分之间耦合度太高，流程不够清晰，而且每个方法只能指定一个回调函数。\n            ")]),s._v(" "),t("h4",[s._v("二、事件监听")]),s._v(" "),t("p",[s._v("onclick 的写法，在异步编程中，称为事件监听。它的思路是：如果任务的执行不取决于代码的顺序，而取决于某个事件是否发生，也就事件驱动模式。")]),s._v(" "),t("p",[s._v("\n                还是 f1 和 f2 的例子，为了简化代码，这里采用jQuery的写法：\n                "),t("pre",{staticClass:"hljs javascript"},[t("code",[t("span",{staticClass:"hljs-comment"},[s._v("// 为f1绑定一个事件，当f1发生done事件，就执行f2")]),t("br"),s._v("f1.on("),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),s._v(", f2);"),t("br"),t("br"),t("span",{staticClass:"hljs-comment"},[s._v("// 改写f1")]),t("br"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("f1")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{"),t("br"),s._v("    setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-comment"},[s._v("// f1的任务代码，执行完成后，立即触发done事件")]),t("br"),s._v("        f1.trigger("),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),s._v(");"),t("br"),s._v("    }, "),t("span",{staticClass:"hljs-number"},[s._v("1000")]),s._v(");"),t("br"),s._v("}")])]),s._v("\n                它的优点是：比较容易理解，耦合度降低了。可以绑定多个事件，而且每个事件还能指定多个回调函数。\n            ")]),s._v(" "),t("p",[s._v("\n                缺点是：整个程序都会变为由事件来驱动，流程会变得很不清晰。\n            ")]),s._v(" "),t("h4",[s._v("三、发布/订阅")]),s._v(" "),t("p",[s._v("\n                这是一种为了处理一对多的业务场景而诞生的设计模式，它也是一种异步编程的方法。vue中MVVM的实现，就有它的功劳。\n            ")]),s._v(" "),t("p",[s._v('\n                关于概念，我们可以这样理解，假定存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。\n            ')]),s._v(" "),t("p",[s._v("\n                下面的例子，采用的是 Morgan Roderick 的\n                "),t("a",{attrs:{href:"https://github.com/mroderick/PubSubJS",target:"_blank"}},[s._v("PubSubJS")]),s._v("\n                ，这是一个无依赖的JavaScript插件：\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("import")]),s._v(" PubSub "),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'pubsub-js'")]),s._v(";"),t("br"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" f2向 "),t("span",{staticClass:"hljs-string"},[s._v("'PubSub'")]),s._v(" 订阅信号 "),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),t("br"),s._v("PubSub.subscribe("),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),s._v(", f2);"),t("br"),t("br"),s._v("const f1 = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("    setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" f1执行完成后，向 "),t("span",{staticClass:"hljs-string"},[s._v("'PubSub'")]),s._v(" 发布信号 "),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),s._v("，从而执行 f2"),t("br"),s._v("        PubSub.publish("),t("span",{staticClass:"hljs-string"},[s._v("'done'")]),s._v(");"),t("br"),s._v("    }, "),t("span",{staticClass:"hljs-number"},[s._v("1000")]),s._v(");"),t("br"),s._v("};"),t("br"),s._v("f1();"),t("br"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" f2 完成执行后，也可以取消订阅"),t("br"),s._v("PubSub.unsubscribe("),t("span",{staticClass:"hljs-string"},[s._v('"done"')]),s._v(", f2);")])]),s._v("\n                这种模式有点类似于“事件监听”，但是明显优于后者。因为，我们可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n            ")]),s._v(" "),t("h4",[s._v("四、Promise对象")]),s._v(" "),t("p",[s._v("接下来，我们聊聊与ajax相关的异步编程方法，Promise对象。")]),s._v(" "),t("p",[s._v("\n                Promise 是由 CommonJS 提出的一种规范，它是为了解决回调函数嵌套，也就是"),t("strong",[s._v("回调地狱")]),s._v("的问题。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n            ")]),s._v(" "),t("p",[s._v("\n                继续改写 f1 和 f2：\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const f1 = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Promise("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("(resolve, reject)")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("        let timeOut = Math.random() * "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";"),t("br"),s._v("        setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (timeOut < "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(") {"),t("br"),s._v("                resolve("),t("span",{staticClass:"hljs-string"},[s._v("'200 OK'")]),s._v(");"),t("br"),s._v("            } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {"),t("br"),s._v("                reject("),t("span",{staticClass:"hljs-string"},[s._v("'timeout in '")]),s._v(" + timeOut + "),t("span",{staticClass:"hljs-string"},[s._v("' seconds.'")]),s._v(");"),t("br"),s._v("            }"),t("br"),s._v("        }, "),t("span",{staticClass:"hljs-number"},[s._v("1000")]),s._v(");"),t("br"),s._v("    });  "),t("br"),s._v("};"),t("br"),t("br"),s._v("const f2 = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'start f2'")]),s._v(");  "),t("br"),s._v("};"),t("br"),t("br"),s._v("f1()."),t("span",{staticClass:"hljs-keyword"},[s._v("then")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("(result)")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(result);"),t("br"),s._v("    f2();"),t("br"),s._v("})."),t("span",{staticClass:"hljs-keyword"},[s._v("catch")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("(reason)")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("    ..."),t("br"),s._v(");")])]),s._v("\n                例子中，用随机数模拟了请求的超时。当 f1 返回 Promise 的 resolve 时，执行 f2。\n            ")]),s._v(" "),t("p",[s._v("\n                Promise的优点是：回调函数变成了链式的写法，程序的流程可以看得很清楚。还有就是，如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个状态。\n            ")]),s._v(" "),t("p",[s._v("\n                缺点就是：编写和理解，都相对比较难。\n            ")]),s._v(" "),t("h4",[s._v("五、Generator")]),s._v(" "),t("p",[s._v("\n                generator（生成器）是 ES6 标准引入的数据类型。它最大特点，就是可以交出函数的执行权（即暂停执行），是协程在 ES6 中的实现。\n            ")]),s._v(" "),t("p",[s._v("\n                看上去它像一个函数，定义如下：\n                "),t("pre",{staticClass:"hljs javascript"},[t("code",{},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("* "),t("span",{staticClass:"hljs-title"},[s._v("gen")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("x")]),s._v(")")]),s._v(" {"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" y = "),t("span",{staticClass:"hljs-keyword"},[s._v("yield")]),s._v(" x + "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" y;"),t("br"),s._v("}")])]),s._v("\n                它不同于普通函数，函数名之前要加星号("),t("code",[s._v("*")]),s._v(")，是可以暂停执行的。\n            ")]),s._v(" "),t("p",[s._v("\n                整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。用 yield 语句注明异步操作需要暂停的地方。\n            ")]),s._v(" "),t("p",[s._v("\n                我们来看一下 Generator 函数执行的过程：\n                "),t("pre",{staticClass:"hljs q"},[t("code",{},[t("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" g = gen("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(");"),t("br"),t("span",{staticClass:"hljs-comment"},[t("br"),s._v("// { value: 3, done: false }")]),t("br"),s._v("g."),t("span",{staticClass:"hljs-built_in"},[s._v("next")]),s._v("();"),t("br"),t("span",{staticClass:"hljs-comment"},[s._v("// { value: undefined, done: true }")]),t("br"),s._v("g."),t("span",{staticClass:"hljs-built_in"},[s._v("next")]),s._v("();")])]),s._v("\n                上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。\n            ")]),s._v(" "),t("p",[s._v("\n                换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。\n            ")]),s._v(" "),t("h4",[s._v("六、async/await")]),s._v(" "),t("p",[s._v("\n                这是 ES8 中提出的一种更优雅的异步解决方案，灵感来自于 C# 语言。具体可前往\n                "),t("router-link",{attrs:{to:{name:"async-await"}}},[s._v("细说 async/await 相较于 Promise 的优势")]),s._v("\n                ，深入理解其原理及特性。\n            ")],1),s._v(" "),t("p",[s._v("\n                来看个例子，要实现一个暂停功能，输入 N 毫秒，则停顿 N 毫秒后才继续往下执行。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" sleep = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("time")]),s._v(") =>")]),s._v(" {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {"),t("br"),s._v("        setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {"),t("br"),s._v("            resolve();"),t("br"),s._v("        }, time);"),t("br"),s._v("    })"),t("br"),s._v("};"),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" start = "),t("span",{staticClass:"hljs-keyword"},[s._v("async")]),s._v(" () => {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'start'")]),s._v(");"),t("br"),s._v("    "),t("span",{staticClass:"hljs-comment"},[s._v("// 在这里使用起来就像同步代码那样直观")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("await")]),s._v(" sleep("),t("span",{staticClass:"hljs-number"},[s._v("1000")]),s._v(");"),t("br"),s._v("    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-string"},[s._v("'end'")]),s._v(");"),t("br"),s._v("};"),t("br"),t("br"),s._v("start();")])]),s._v("\n                控制台先输出 start，稍等 1 秒后，输出结果 ok，最后输出 end。\n            ")]),s._v(" "),t("p",[s._v("\n                解析一下上述代码：\n                "),t("ul",[t("li",[s._v("\n                        async 表示这是一个async函数，await 只能用在这个函数里面。\n                    ")]),s._v(" "),t("li",[s._v("\n                        await 表示在这里等待 promise 返回了结果，再继续执行。\n                    ")]),s._v(" "),t("li",[s._v("\n                        使用起来，就像写同步代码一样地优雅。\n                    ")])])]),s._v(" "),t("h2",[s._v("总结")]),s._v(" "),t("p",[s._v("\n                JavaScript的异步编写方式，从 回调函数 到 async/await，感觉在写法上，每次都有进步，其本质就是一次次对语言层抽象的优化。以至于现在，我们可以像同步一样地，去处理异步。\n            ")]),s._v(" "),t("p",[s._v("\n                换句话说就是："),t("strong",[s._v("异步编程的最高境界，就是根本不用关心它是不是异步")]),s._v("。\n            ")])])])],1)},[],!1,null,null,null);_.options.__file="async-in-javascript.vue";a.default=_.exports}}]);