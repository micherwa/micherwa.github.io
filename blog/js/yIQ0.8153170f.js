(window.webpackJsonp=window.webpackJsonp||[]).push([["yIQ0"],{yIQ0:function(s,a,t){"use strict";t.r(a);var l={},r=t("psIG"),_=Object(r.a)(l,function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("div",{staticClass:"blog-container"},[t("BlogHeader"),s._v(" "),t("BlogContent",{attrs:{useCatalog:!0}},[t("div",{attrs:{slot:"content"},slot:"content"},[t("h2",[s._v("前言")]),s._v(" "),t("p",[s._v("这是前端面试题系列的第 8 篇，你可能错过了前面的篇章，可以在这里找到：")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c727abde51d457fc564cd77",target:"_blank"}},[s._v("浏览器中的事件机制（涉及主流框架）")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c677041f265da2de25b7707",target:"_blank"}},[s._v("理解函数的柯里化")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c612a60f265da2da15d9986",target:"_blank"}},[s._v("ES6 中箭头函数的用法")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c428ce0f265da612b13dca7",target:"_blank"}},[s._v("this 的原理以及用法")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c36fd0f6fb9a049cd5465cd",target:"_blank"}},[s._v("伪类与伪元素的区别及实战")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c394fece51d45524c7cc712",target:"_blank"}},[s._v("如何实现一个圣杯布局？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c394da4518825253661bd4d",target:"_blank"}},[s._v("今日头条 面试题和思路解析")])])]),s._v(" "),t("p",[s._v("\n                前端面试中经常会问到数组去重的问题。因为在平时的工作中遇到复杂交互的时候，需要知道该如何解决。另外，我在问应聘者这道题的时候，更多的是想考察 2 个点：对 Array 方法的熟悉程度，还有逻辑算法能力。一般我会先让应聘者说出几种方法，然后随机抽取他说的一种，具体地写一下。\n            ")]),s._v(" "),t("p",[s._v("\n                这里有一个通用的面试技巧：自己不熟悉的东西，千万别说！我就碰到过几个应聘者，想尽可能地表现自己，就说了不少方法，随机抽了一个，结果就没写出来，很尴尬。\n            ")]),s._v(" "),t("p",[s._v("\n                ok，让我们马上开始今天的主题。会介绍 10 种不同类型的方法，一些类似的方法我做了合并，写法从简到繁，其中还会有 loadsh 源码中的方法。\n            ")]),s._v(" "),t("h2",[s._v("10 种去重方法")]),s._v(" "),t("p",[s._v("\n                假设有一个这样的数组： "),t("code",[s._v("let originalArray = [1, '1', '1', 2,  true, 'true', false, false, null, null, {}, {}, 'abc', 'abc', undefined, undefined, NaN, NaN];")]),s._v("。后面的方法中的源数组，都是指的这个。\n            ")]),s._v(" "),t("h4",[s._v("1、ES6 的 Set 对象")]),s._v(" "),t("p",[s._v("\n                ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("let resultArr = Array."),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v("("),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Set(originalArray));"),t("br"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 或者用扩展运算符"),t("br"),s._v("let resultArr = [..."),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Set(originalArray)];"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                Set 并不是真正的数组，这里的 "),t("code",[s._v("Array.from")]),s._v(" 和 "),t("code",[s._v("...")]),s._v(" 都可以将 Set 数据结构，转换成最终的结果数组。\n            ")]),s._v(" "),t("p",[s._v("\n                这是最简单快捷的去重方法，但是细心的同学会发现，这里的 "),t("code",[s._v("{}")]),s._v(" 没有去重。可是又转念一想，2 个空对象的地址并不相同，所以这里并没有问题，结果 ok。\n            ")]),s._v(" "),t("h4",[s._v("2、Map 的 has 方法")]),s._v(" "),t("p",[s._v("\n                把源数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。\n                "),t("pre",{staticClass:"hljs javascript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" resultArr = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Array")]),s._v("();"),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-comment"},[s._v("// 没有该 key 值")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!map.has(originalArray[i])) {"),t("br"),s._v("        map.set(originalArray[i], "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(");"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-comment"},[s._v('// [1, "1", 2, true, "true", false, null, {…}, {…}, "abc", undefined, NaN]')])])]),s._v("\n                但是它与 Set 的数据结构比较相似，结果 ok。\n            ")]),s._v(" "),t("h4",[s._v("3、indexOf 和 includes")]),s._v(" "),t("p",[s._v("\n                建立一个新的空数组，遍历源数组，往这个空数组里塞值，每次 push 之前，先判断是否已有相同的值。\n            ")]),s._v(" "),t("p",[s._v("\n                判断的方法有 2 个：indexOf 和 includes，但它们的结果之间有细微的差别。先看 indexOf。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const resultArr = [];"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (resultArr.indexOf(originalArray[i]) < "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") {"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN, NaN]"),t("br")])]),s._v("\n                indexOf 并不没处理 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                再来看 includes，它是在 ES7 中正式提出的。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const resultArr = [];"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!resultArr.includes(originalArray[i])) {"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                includes 处理了 "),t("code",[s._v("NaN")]),s._v("，结果 ok。\n            ")]),s._v(" "),t("h4",[s._v("4、sort")]),s._v(" "),t("p",[s._v("\n                先将原数组排序，生成新的数组，然后遍历排序后的数组，相邻的两两进行比较，如果不同则存入新数组。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const sortedArr = originalArray.sort();"),t("br"),t("br"),s._v("const resultArr = [sortedArr["),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("]];"),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let i = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("; i < sortedArr.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (sortedArr[i] !== resultArr[resultArr.length - "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("]) {"),t("br"),s._v("        resultArr.push(sortedArr[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", NaN, NaN, {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v("]")])]),s._v("\n                从结果可以看出，对源数组进行了排序。但同样的没有处理 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("5、双层 for 循环 + splice")]),s._v(" "),t("p",[s._v("\n                双层循环，外层遍历源数组，内层从 i+1 开始遍历比较，相同时删除这个值。\n                "),t("pre",{staticClass:"hljs lisp"},[t("code",{staticClass:"focus"},[s._v("for ("),t("span",{staticClass:"hljs-name"},[s._v("let")]),s._v(" i = 0; i < originalArray.length; i++) {"),t("br"),s._v("    for ("),t("span",{staticClass:"hljs-name"},[s._v("let")]),s._v(" j = ("),t("span",{staticClass:"hljs-name"},[s._v("i")]),s._v(" + "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("); j < originalArray.length; j++) {"),t("br"),s._v("        // 第一个等于第二个，splice去掉第二个"),t("br"),s._v("        if ("),t("span",{staticClass:"hljs-name"},[s._v("originalArray")]),s._v("[i] === originalArray[j]) {"),t("br"),s._v("            originalArray.splice("),t("span",{staticClass:"hljs-name"},[s._v("j")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")"),t("span",{staticClass:"hljs-comment"},[s._v(";")]),t("br"),s._v("            j--;"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("br"),s._v("console.log("),t("span",{staticClass:"hljs-name"},[s._v("originalArray")]),s._v(")"),t("span",{staticClass:"hljs-comment"},[s._v(";")]),t("br"),t("span",{staticClass:"hljs-comment"},[s._v('// [1, "1", 2, true, "true", false, null, {…}, {…}, "abc", undefined, NaN, NaN]')])])]),s._v("\n                splice 方法会修改源数组，所以这里我们并没有新开空数组去存储，最终输出的是修改之后的源数组。但同样的没有处理 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("6、原始去重")]),s._v(" "),t("p",[s._v("\n                定义一个新数组，并存放原数组的第一个元素，然后将源数组一一和新数组的元素对比，若不同则存放在新数组中。\n                "),t("pre",{staticClass:"hljs lua"},[t("code",{},[s._v("let resultArr = [originalArray["),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("]];"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("(var i = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("; i < originalArray.length; i++){"),t("br"),s._v("    var "),t("span",{staticClass:"hljs-keyword"},[s._v("repeat")]),s._v(" = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(";"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("(var j="),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; j < resultArr.length; j++){"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(originalArray[i] === resultArr[j]){"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("repeat")]),s._v(" = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(";"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("break")]),s._v(";"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(!"),t("span",{staticClass:"hljs-keyword"},[s._v("repeat")]),s._v("){"),t("br"),s._v("       resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),s._v("console."),t("span",{staticClass:"hljs-built_in"},[s._v("log")]),s._v("(resultArr);"),t("br"),s._v("// ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", null, {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", undefined, NaN, NaN]")])]),s._v("\n                这是最原始的去重方法，很好理解，但写法繁琐。同样的没有处理 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("7、ES5 的 reduce")]),s._v(" "),t("p",[s._v("\n                reduce 是 ES5 中方法，常用于值的累加。它的语法：\n                "),t("pre",{staticClass:"hljs css"},[t("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[t("span",{staticClass:"hljs-selector-tag"},[s._v("arr")]),t("span",{staticClass:"hljs-selector-class"},[s._v(".reduce")]),s._v("("),t("span",{staticClass:"hljs-selector-tag"},[s._v("callback")]),t("span",{staticClass:"hljs-selector-attr"},[s._v("[, initialValue]")]),s._v(")")])]),s._v("\n                reduce 的第一个参数是一个 callback，callback 中的参数分别为： Accumulator(累加器)、currentValue(当前正在处理的元素)、currentIndex(当前正在处理的元素索引，可选)、array(调用 reduce 的数组，可选)。\n            ")]),s._v(" "),t("p",[s._v("\n                reduce 的第二个参数，是作为第一次调用 callback 函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。\n            ")]),s._v(" "),t("p",[s._v("\n                利用 reduce 的特性，再结合之前的 includes(也可以用 indexOf)，就能得到新的去重方法：\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const reducer = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("(acc, cur)")]),s._v(" =>")]),s._v(" acc.includes(cur) ? acc : [...acc, cur];"),t("br"),t("br"),s._v("const resultArr = originalArray.reduce(reducer, []);"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                这里的 "),t("code",[s._v("[]")]),s._v(" 就是初始值(initialValue)。acc 是累加器，在这里的作用是将没有重复的值塞入新数组（它一开始是空的）。 reduce 的写法很简单，但需要多加理解。它可以处理 "),t("code",[s._v("NaN")]),s._v("，结果 ok。\n            ")]),s._v(" "),t("h4",[s._v("8、对象的属性")]),s._v(" "),t("p",[s._v("\n                每次取出原数组的元素，然后在对象中访问这个属性，如果存在就说明重复。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const resultArr = [];"),t("br"),s._v("const obj = {};"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("(let i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++){"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(!obj[originalArray[i]]){"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("        obj[originalArray[i]] = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                但这种方法有缺陷。从结果看，它貌似只关心值，不关注类型。还把 "),t("code",[s._v("{}")]),s._v(" 给处理了，但这不是正统的处理办法，所以 "),t("strong",[s._v("不推荐使用")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("9、filter + hasOwnProperty")]),s._v(" "),t("p",[s._v("\n                filter 方法会返回一个新的数组，新数组中的元素，通过 hasOwnProperty 来检查是否为符合条件的元素。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const obj = {};"),t("br"),s._v("const resultArr = originalArray.filter(function (item) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" obj.hasOwnProperty("),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" item + item) ? "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(" : (obj["),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" item + item] = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(");"),t("br"),s._v("});"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                这 "),t("code",[s._v("貌似")]),s._v(" 是目前看来最完美的解决方案了。这里稍加解释一下：\n                "),t("ul",[t("li",[s._v("\n                        hasOwnProperty 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。\n                    ")]),s._v(" "),t("li",[t("code",[s._v("typeof item + item")]),s._v(" 的写法，是为了保证值相同，但类型不同的元素被保留下来。例如：第一个元素为 number1，第二第三个元素都是 string1，所以第三个元素就被去除了。\n                    ")]),s._v(" "),t("li",[t("code",[s._v("obj[typeof item + item] = true")]),s._v(" 如果 hasOwnProperty 没有找到该属性，则往 obj 里塞键值对进去，以此作为下次循环的判断依据。\n                    ")]),s._v(" "),t("li",[s._v("\n                        如果 hasOwnProperty 没有检测到重复的属性，则告诉 filter 方法可以先积攒着，最后一起输出。\n                    ")])])]),s._v(" "),t("p",[t("code",[s._v("看似")]),s._v(" 完美解决了我们源数组的去重问题，但在实际的开发中，一般不会给两个空对象给我们去重。所以稍加改变源数组，给两个空对象中加入键值对。\n                "),t("pre",{staticClass:"hljs typescript"},[t("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" originalArray = ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'1'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'1'")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'true'")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {a: "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("}, {a: "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("}, "),t("span",{staticClass:"hljs-string"},[s._v("'abc'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'abc'")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("NaN")]),s._v("];")])]),s._v("\n                然后再用 filter + hasOwnProperty 去重。\n            ")]),s._v(" "),t("p",[s._v("\n                然而，结果竟然把 "),t("code",[s._v("{a: 2}")]),s._v(" 给去除了！！！这就不对了。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，这种方法有点去重 "),t("code",[s._v("过头")]),s._v(" 了，也是存在问题的。\n            ")]),s._v(" "),t("h4",[s._v("10、lodash 中的 _.uniq")]),s._v(" "),t("p",[s._v("\n                灵机一动，让我想到了 lodash 的去重方法 _.uniq，那就尝试一把：\n                "),t("pre",{staticClass:"hljs perl"},[t("code",{},[s._v("console.log("),t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".uni"),t("span",{staticClass:"hljs-string"},[s._v("q(originalArray)")]),s._v(");"),t("br"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", true, "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", false, null, {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", undefined, NaN, NaN]")])]),s._v("\n                用法很简单， 可以在实际工作中正确处理去重问题。\n            ")]),s._v(" "),t("p",[s._v("\n                然后，我在好奇心促使下，看了它的源码，指向了 _.baseUniq 文件，它的源码如下：\n                "),t("pre",{staticClass:"hljs cs"},[t("code",{},[t("span",{staticClass:"hljs-function"},[s._v("function "),t("span",{staticClass:"hljs-title"},[s._v("baseUniq")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("array, iteratee, comparator")]),s._v(")")]),s._v(" {"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),t("span",{staticClass:"hljs-number"},[s._v("-1")]),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" includes = arrayIncludes"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),t("br"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" { length } = array"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" result = []"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" seen = "),t("span",{staticClass:"hljs-function"},[s._v("result")]),t("br"),t("span",{staticClass:"hljs-function"}),t("br"),t("span",{staticClass:"hljs-function"},[s._v("  "),t("span",{staticClass:"hljs-title"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("comparator")]),s._v(")")]),s._v(" {"),t("br"),s._v("    isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("    includes = arrayIncludesWith"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (length >= LARGE_ARRAY_SIZE) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" = iteratee ? "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(" : createSet(array)"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(") {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" setToArray("),t("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("    isCommon = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),t("br"),s._v("    includes = cacheHas"),t("br"),s._v("    seen = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" SetCache"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {"),t("br"),s._v("    seen = iteratee ? [] : result"),t("br"),s._v("  }"),t("br"),s._v("  outer:"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (++index < length) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = array[index]"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" computed = iteratee ? iteratee("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(") : "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" = (comparator || "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" !== "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") ? "),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(" : "),t("span",{staticClass:"hljs-number"},[s._v("0")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (isCommon && computed === computed) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" seenIndex = seen."),t("span",{staticClass:"hljs-function"},[s._v("length")]),t("br"),t("span",{staticClass:"hljs-function"},[s._v("      "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("seenIndex--")]),s._v(")")]),s._v(" {"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (seen[seenIndex] === computed) {"),t("br"),s._v("          "),t("span",{staticClass:"hljs-keyword"},[s._v("continue")]),s._v(" outer"),t("br"),s._v("        }"),t("br"),s._v("      }"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (iteratee) {"),t("br"),s._v("        seen.push(computed)"),t("br"),s._v("      }"),t("br"),s._v("      result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!includes(seen, computed, comparator)) {"),t("br"),s._v("      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (seen !== result) {"),t("br"),s._v("        seen.push(computed)"),t("br"),s._v("      }"),t("br"),s._v("      result.push("),t("span",{staticClass:"hljs-keyword"},[s._v("value")]),s._v(")"),t("br"),s._v("    }"),t("br"),s._v("  }"),t("br"),s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" result"),t("br"),s._v("}")])]),s._v("\n                有比较多的干扰项，去除掉之后，就会发现它用了 "),t("code",[s._v("while")]),s._v(" 做循环，当遇到值相同的时候，"),t("code",[s._v("continue outer")]),s._v(" 再次进入循环进行比较，将没有重复的值塞进 "),t("code",[s._v("result")]),s._v(" 里，最终输出。\n            ")]),s._v(" "),t("p",[s._v("\n                另外，lodash 里还有一个 _.uniqBy 方法，它可以通过指定 key，来专门去重对象列表，感觉还挺实用的。它的源码还是指向了 "),t("code",[s._v("_.baseUniq")]),s._v("。\n                "),t("pre",{staticClass:"hljs ruby"},[t("code",{},[t("span",{staticClass:"hljs-number"},[s._v("_")]),s._v(".uniqBy([{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }], "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(");"),t("span",{staticClass:"hljs-regexp"},[t("br"),s._v("//")]),s._v(" => [{ "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" }, { "),t("span",{staticClass:"hljs-string"},[s._v("'x'")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" }]")])])]),s._v(" "),t("h2",[s._v("总结")]),s._v(" "),t("p",[s._v("\n                从上述的这些方法来看，ES6 开始出现的方法（如 Set、Map、includes），都能完美地解决我们日常开发中的去重需求，关键它们还都是原生的，写法还更简单。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，我们提倡拥抱原生，因为它们真的没有那么难以理解，至少在这里我觉得它比 lodash 里 _.uniq 的源码要好理解得多，关键是还能解决问题。\n            ")])])])],1)},[],!1,null,null,null);_.options.__file="array-de-duplicate.vue";a.default=_.exports}}]);