(window.webpackJsonp=window.webpackJsonp||[]).push([["yIQ0"],{yIQ0:function(s,a,t){"use strict";t.r(a);var l={},r=t("psIG"),_=Object(r.a)(l,function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("div",{staticClass:"blog-container"},[t("BlogHeader"),s._v(" "),t("BlogContent",{attrs:{useCatalog:!0}},[t("div",{attrs:{slot:"content"},slot:"content"},[t("h2",[s._v("前言")]),s._v(" "),t("p",[s._v("这是前端面试题系列的第 8 篇，你可能错过了前面的篇章，可以在这里找到：")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c727abde51d457fc564cd77",target:"_blank"}},[s._v("浏览器中的事件机制（涉及主流框架）")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c677041f265da2de25b7707",target:"_blank"}},[s._v("理解函数的柯里化")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c612a60f265da2da15d9986",target:"_blank"}},[s._v("ES6 中箭头函数的用法")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c428ce0f265da612b13dca7",target:"_blank"}},[s._v("this 的原理以及用法")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c36fd0f6fb9a049cd5465cd",target:"_blank"}},[s._v("伪类与伪元素的区别及实战")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c394fece51d45524c7cc712",target:"_blank"}},[s._v("如何实现一个圣杯布局？")])]),s._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c394da4518825253661bd4d",target:"_blank"}},[s._v("今日头条 面试题和思路解析")])])]),s._v(" "),t("p",[s._v("\n                前端面试中常会问到数组去重的问题。在平时的工作中，并不常遇到需要去重的情况，因为后端同学一般都会处理好了给我们。但我们前端也免不了在处理复杂交互的时候，还是会遇到需要去重的情况。\n            ")]),s._v(" "),t("p",[s._v("\n                举一个工作中的小例子。假设有一个主列表数据，可以对每一条数据进行编辑。每条数据里，可以有 N 张缩略图。所有缩略图，可以根据指定条件进行过滤生成一个缩略图列表，有时候比较多，就会有翻页。通过编辑，可以弹出缩略图列表的层，这些缩略图可以多选，并且是可以分页多选。选完之后，将缩略图的信息，在主列表中更新展示出来。这时，就需要我们自己去维护主列表与缩略图的关系了，并且编辑完成后的缩略图是不可重复的，那就会遇到需要去重的情况了。\n            ")]),s._v(" "),t("p",[s._v("\n                我在问数组去重的时候，更多的是想考察应聘者 2 个点：对 Array 方法的熟悉程度，还有逻辑算法能力。一般我会先让应聘者说出几种方法，然后随机抽取他说的一种，让他具体地写一下。\n            ")]),s._v(" "),t("p",[s._v("\n                所以，这里有一个通用的面试技巧：自己不熟悉的东西，千万别说！我就碰到过几个应聘者，想尽可能地表现自己，说了自己不熟悉的方法，结果就没写出来，很尴尬。\n            ")]),s._v(" "),t("p",[s._v("\n                ok，让我们马上开始今天的主题。会介绍 9 种不同类型的方法，一些类似的方法做了合并，写法从简到繁。\n            ")]),s._v(" "),t("h2",[s._v("9 种去重方法")]),s._v(" "),t("p",[s._v("\n                假设有一个这样的数组： "),t("code",[s._v("let originalArray = [1, '1', '1', 2,  true, 'true', false, false, null, null, {}, {}, 'abc', 'abc', undefined, undefined, NaN, NaN];")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("1、ES6 的 Set 对象")]),s._v(" "),t("p",[s._v("\n                ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("let resultArr = Array."),t("span",{staticClass:"hljs-keyword"},[s._v("from")]),s._v("("),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Set(originalArray));"),t("br"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" 或者用扩展运算符"),t("br"),s._v("let resultArr = [..."),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Set(originalArray)];"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                Set 并不是真正的数组，这里的 "),t("code",[s._v("Array.from")]),s._v(" 和 "),t("code",[s._v("...")]),s._v(" 都可以将 Set 数据结构，转换成最终的结果数组。\n            ")]),s._v(" "),t("p",[s._v("\n                这是最简单快捷的去重方法，但有一个问题 "),t("code",[s._v("{}")]),s._v(" 没有去重，为什么没法去重对象呢？因为它们的地址不一样呗，尽管它们长得一样，都是空对象。不要担心，后面会有方法可以解决。\n            ")]),s._v(" "),t("h4",[s._v("2、Map 的 has 方法")]),s._v(" "),t("p",[s._v("\n                把源数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。\n                "),t("pre",{staticClass:"hljs javascript"},[t("code",{},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" resultArr = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Array")]),s._v("();"),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-comment"},[s._v("// 没有该 key 值")]),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!map.has(originalArray[i])) {"),t("br"),s._v("        map.set(originalArray[i], "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(");"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-comment"},[s._v('// [1, "1", 2, true, "true", false, null, {…}, {…}, "abc", undefined, NaN]')])])]),s._v("\n                但是它与 Set 一样，还是没解决 "),t("code",[s._v("{}")]),s._v(" 的问题。\n            ")]),s._v(" "),t("h4",[s._v("3、indexOf 和 includes")]),s._v(" "),t("p",[s._v("\n                建立一个新的空数组，遍历源数组，往这个空数组里塞值，每次 push 之前，先判断是否已有相同的值。\n            ")]),s._v(" "),t("p",[s._v("\n                判断的方法有 2 个：indexOf 和 includes，但它们的结果之间有细微的差别。先看 indexOf。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const resultArr = [];"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (resultArr.indexOf(originalArray[i]) < "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") {"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN, NaN]"),t("br")])]),s._v("\n                indexOf 并不没处理 "),t("code",[s._v("{}")]),s._v(" 和 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("p",[s._v("\n                再来看 includes，它是在 ES7 中正式提出的。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const resultArr = [];"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!resultArr.includes(originalArray[i])) {"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                includes 处理了 "),t("code",[s._v("NaN")]),s._v("，却还是没能处理 "),t("code",[s._v("{}")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("4、sort")]),s._v(" "),t("p",[s._v("\n                先将原数组排序，生成新的数组，然后遍历排序后的数组，相邻的两两进行比较，如果不同则存入新数组。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const sortedArr = originalArray.sort();"),t("br"),t("br"),s._v("const resultArr = [sortedArr["),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("]];"),t("br"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let i = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("; i < sortedArr.length; i++) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (sortedArr[i] !== resultArr[resultArr.length - "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("]) {"),t("br"),s._v("        resultArr.push(sortedArr[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", NaN, NaN, {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v("]")])]),s._v("\n                可以从结果看出排序的结果。同样的没有处理 "),t("code",[s._v("{}")]),s._v(" 和 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("5、双层 for 循环 + splice")]),s._v(" "),t("p",[s._v("\n                双层循环，外层遍历源数组，内层从 i+1 开始遍历比较，相同时删除这个值。\n                "),t("pre",{staticClass:"hljs lisp"},[t("code",{staticClass:"focus"},[s._v("for ("),t("span",{staticClass:"hljs-name"},[s._v("let")]),s._v(" i = 0; i < originalArray.length; i++) {"),t("br"),s._v("    for ("),t("span",{staticClass:"hljs-name"},[s._v("let")]),s._v(" j = ("),t("span",{staticClass:"hljs-name"},[s._v("i")]),s._v(" + "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("); j < originalArray.length; j++) {"),t("br"),s._v("        // 第一个等于第二个，splice去掉第二个"),t("br"),s._v("        if ("),t("span",{staticClass:"hljs-name"},[s._v("originalArray")]),s._v("[i] === originalArray[j]) {"),t("br"),s._v("            originalArray.splice("),t("span",{staticClass:"hljs-name"},[s._v("j")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")"),t("span",{staticClass:"hljs-comment"},[s._v(";")]),t("br"),s._v("            j--;"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("br"),s._v("console.log("),t("span",{staticClass:"hljs-name"},[s._v("originalArray")]),s._v(")"),t("span",{staticClass:"hljs-comment"},[s._v(";")]),t("br"),t("span",{staticClass:"hljs-comment"},[s._v('// [1, "1", 2, true, "true", false, null, {…}, {…}, "abc", undefined, NaN, NaN]')])])]),s._v("\n                splice 方法会修改源数组，所以这里我们并没有新开空数组去存储，最终输出的是修改之后的源数组。但同样的没有处理 "),t("code",[s._v("{}")]),s._v(" 和 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("6、原始去重")]),s._v(" "),t("p",[s._v("\n                定义一个新数组，并存放原数组的第一个元素，然后将源数组一一和新数组的元素对比，若不同则存放在新数组中。\n                "),t("pre",{staticClass:"hljs lua"},[t("code",{},[s._v("let resultArr = [originalArray["),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("]];"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("(var i = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("; i < originalArray.length; i++){"),t("br"),s._v("    var "),t("span",{staticClass:"hljs-keyword"},[s._v("repeat")]),s._v(" = "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(";"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("(var j="),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; j < resultArr.length; j++){"),t("br"),s._v("        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(originalArray[i] === resultArr[j]){"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("repeat")]),s._v(" = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(";"),t("br"),s._v("            "),t("span",{staticClass:"hljs-keyword"},[s._v("break")]),s._v(";"),t("br"),s._v("        }"),t("br"),s._v("    }"),t("br"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(!"),t("span",{staticClass:"hljs-keyword"},[s._v("repeat")]),s._v("){"),t("br"),s._v("       resultArr.push(originalArray[i]);"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),s._v("console."),t("span",{staticClass:"hljs-built_in"},[s._v("log")]),s._v("(resultArr);"),t("br"),s._v("// ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", null, {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", undefined, NaN, NaN]")])]),s._v("\n                这是最原始的去重方法，很好理解，但写法繁琐。同样的没有处理 "),t("code",[s._v("{}")]),s._v(" 和 "),t("code",[s._v("NaN")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("7、ES5 的 reduce")]),s._v(" "),t("p",[s._v("\n                reduce 是 ES5 中方法，常用于值的累加。它的语法：\n                "),t("pre",{staticClass:"hljs css"},[t("code",{staticStyle:{"word-break":"break-word","white-space":"initial"}},[t("span",{staticClass:"hljs-selector-tag"},[s._v("arr")]),t("span",{staticClass:"hljs-selector-class"},[s._v(".reduce")]),s._v("("),t("span",{staticClass:"hljs-selector-tag"},[s._v("callback")]),t("span",{staticClass:"hljs-selector-attr"},[s._v("[, initialValue]")]),s._v(")")])]),s._v("\n                reduce 的第一个参数是一个 callback，callback 中的参数分别为： Accumulator(累加器)、currentValue(当前正在处理的元素)、currentIndex(当前正在处理的元素索引，可选)、array(调用 reduce 的数组，可选)。\n            ")]),s._v(" "),t("p",[s._v("\n                reduce 的第二个参数，是作为第一次调用 callback 函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。\n            ")]),s._v(" "),t("p",[s._v("\n                利用 reduce 的特性，再结合之前的 includes(也可以用 indexOf)，就能得到新的去重方法：\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const reducer = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("(acc, cur)")]),s._v(" =>")]),s._v(" acc.includes(cur) ? acc : [...acc, cur];"),t("br"),t("br"),s._v("const resultArr = originalArray.reduce(reducer, []);"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                这里的 "),t("code",[s._v("[]")]),s._v(" 就是初始值(initialValue)。acc 是累加器，在这里的作用是将没有重复的值塞入新数组（它一开始是空的）。 reduce 的写法很简单，但需要多加理解。它可以处理 "),t("code",[s._v("NaN")]),s._v("，却没能处理 "),t("code",[s._v("{}")]),s._v("。\n            ")]),s._v(" "),t("h4",[s._v("8、filter + hasOwnProperty")]),s._v(" "),t("p",[s._v("\n                filter 方法会返回一个新的数组，新数组中的元素，通过 hasOwnProperty 来检查是否为符合条件的元素。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const obj = {};"),t("br"),s._v("const resultArr = originalArray.filter(function (item) {"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" obj.hasOwnProperty("),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" item + item) ? "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(" : (obj["),t("span",{staticClass:"hljs-keyword"},[s._v("typeof")]),s._v(" item + item] = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(");"),t("br"),s._v("});"),t("br"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"1"')]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v('"true"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                这是目前看来最完美的解决方案了。这里稍加解释一下：\n                "),t("ul",[t("li",[s._v("\n                        hasOwnProperty 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。\n                    ")]),s._v(" "),t("li",[t("code",[s._v("typeof item + item")]),s._v(" 的写法，是为了保证值相同，但类型不同的元素被保留下来。例如：第一个元素为 number1，第二第三个元素都是 string1，所以第三个元素就被去除了。\n                    ")]),s._v(" "),t("li",[t("code",[s._v("obj[typeof item + item] = true")]),s._v(" 如果 hasOwnProperty 没有找到该属性，则往 obj 里塞键值对进去，以此作为下次循环的判断依据。\n                    ")]),s._v(" "),t("li",[s._v("\n                        如果 hasOwnProperty 没有检测到重复的属性，则告诉 filter 方法可以先积攒着，最后一起输出。\n                    ")])])]),s._v(" "),t("h4",[s._v("9、对象的属性")]),s._v(" "),t("p",[s._v("\n                每次取出原数组的元素，然后在对象中访问这个属性，如果存在就说明重复。\n                "),t("pre",{staticClass:"hljs coffeescript"},[t("code",{},[s._v("const resultArr = [];"),t("br"),s._v("const obj = {};"),t("br"),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("(let i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i < originalArray.length; i++){"),t("br"),s._v("    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(!obj[originalArray[i]]){"),t("br"),s._v("        resultArr.push(originalArray[i]);"),t("br"),s._v("        obj[originalArray[i]] = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";"),t("br"),s._v("    }"),t("br"),s._v("}"),t("br"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(resultArr);"),t("br"),t("span",{staticClass:"hljs-regexp"},[s._v("//")]),s._v(" ["),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(", {…}, "),t("span",{staticClass:"hljs-string"},[s._v('"abc"')]),s._v(", "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v(", NaN]")])]),s._v("\n                但这种方法有缺陷。从结果看，它貌似只关心值，不关注类型。还把 "),t("code",[s._v("{}")]),s._v(" 给处理了，但这不是正统的处理办法，所以 "),t("strong",[s._v("不推荐使用")]),s._v("。\n            ")])])])],1)},[],!1,null,null,null);_.options.__file="array-de-duplicate.vue";a.default=_.exports}}]);