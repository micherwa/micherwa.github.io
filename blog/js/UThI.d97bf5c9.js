(window.webpackJsonp=window.webpackJsonp||[]).push([["UThI"],{UThI:function(s,t,a){"use strict";a.r(t);var l={created:function(){}},n=a("psIG"),_=Object(n.a)(l,function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("div",{staticClass:"blog-container"},[a("BlogHeader",{attrs:{title:"如何实现继承",subTitle:"",date:"2017-06-04",tags:["Javascript"]}}),s._v(" "),a("BlogContent",{attrs:{useCatalog:!0}},[a("div",{attrs:{slot:"content"},slot:"content"},[a("h2",[s._v("前言")]),s._v(" "),a("p",[s._v("\n                这里说的继承，是Javascript面向对象编程(OOP)中的重要概念。\n            ")]),s._v(" "),a("p",[s._v("\n                但由于Javascript不是一种真正的面向对象编程语言，所以继承并非像 Java 中一个 extends 关键字，就能搞定继承的关系。\n            ")]),s._v(" "),a("p",[s._v("\n                所以，本文列举的几种继承的方法，会进行逐步地组合封装，最后会介绍es6中class的继承方法。\n            ")]),s._v(" "),a("p",[s._v("\n                假设，现在有一个“动物”的构造函数。\n                "),a("pre",{staticClass:"hljs actionscript"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Animal")]),a("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".species = "),a("span",{staticClass:"hljs-string"},[s._v('"动物"')]),s._v(";"),a("br"),s._v("}")])]),s._v("\n                还有一个“猫”对象的构造函数。\n                "),a("pre",{staticClass:"hljs qml"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Cat")]),s._v(" ("),a("span",{staticClass:"hljs-params"},[s._v("name, color")]),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name = name;"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = "),a("span",{staticClass:"hljs-built_in"},[s._v("color")]),s._v(";"),a("br"),s._v("}")])]),s._v('\n                如何使"猫"继承"动物"呢？\n            ')]),s._v(" "),a("h2",[s._v("1.构造函数绑定(使用call或apply方法)")]),s._v(" "),a("p",[s._v("\n                就是将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：\n                "),a("pre",{staticClass:"hljs qml"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Cat")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("name, color")]),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-comment"},[s._v("// 将所有在 Animal 中与 this 绑定的变量都切换到了 Cat 上")]),a("br"),s._v("    Animal.apply("),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(", "),a("span",{staticClass:"hljs-built_in"},[s._v("arguments")]),s._v(");"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name = name;"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = "),a("span",{staticClass:"hljs-built_in"},[s._v("color")]),s._v(";"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" cat1 = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Cat("),a("span",{staticClass:"hljs-string"},[s._v('"大毛"')]),s._v(", "),a("span",{staticClass:"hljs-string"},[s._v('"黄色"')]),s._v(");"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")])])]),s._v("\n                但有个问题，无法继承一些原型链上公用的方法或属性。再改写一下：\n                "),a("pre",{staticClass:"hljs javascript"},[a("code",{},[s._v("Animal.prototype.doSomething = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'Animal do something'")]),s._v(");"),a("br"),s._v(" }"),a("br"),s._v(" "),a("br"),s._v(" "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.doSomething());"),a("br"),s._v(" "),a("span",{staticClass:"hljs-comment"},[s._v("// Uncaught TypeError: cat1.doSomething is not a function")])])]),s._v("\n                Animal 有一个公用方法写在 prototype 上，Cat 调用该方法时会发生报错。\n            ")]),s._v(" "),a("h2",[s._v("2.原型链模式(prototype)")]),s._v(" "),a("p",[s._v('\n                如果"猫"的prototype对象，指向一个Animal的实例，那么所有"猫"的实例，就能继承Animal了。\n                '),a("pre",{staticClass:"hljs qml"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Animal")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".species = "),a("span",{staticClass:"hljs-string"},[s._v('"动物"')]),s._v(";"),a("br"),s._v("}"),a("br"),a("br"),s._v("Animal.prototype.doSomething = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'Animal do something'")]),s._v(");"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Cat")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("name, color")]),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name = name;"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = "),a("span",{staticClass:"hljs-built_in"},[s._v("color")]),s._v(";"),a("br"),s._v("}"),a("br"),a("br"),s._v("Cat.prototype = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Animal();"),a("br"),s._v("Cat.prototype.constructor = Cat;"),a("br"),a("br"),a("span",{staticClass:"hljs-comment"},[s._v("// 必须写在 Cat.prototype = new Animal(); 之后")]),a("br"),s._v("Cat.prototype.doSomething = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'Cat catches mouse'")]),s._v(");"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" cat1 = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Cat("),a("span",{staticClass:"hljs-string"},[s._v('"大毛"')]),s._v(", "),a("span",{staticClass:"hljs-string"},[s._v('"黄色"')]),s._v(");"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")]),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.doSomething()); "),a("span",{staticClass:"hljs-comment"},[s._v("// Cat catches mouse")])])]),s._v("\n                先将Cat的prototype对象指向一个Animal的实例："),a("code",[s._v("Cat.prototype = new Animal();")]),s._v("。它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。\n            ")]),s._v(" "),a("p",[a("code",[s._v("Cat.prototype.constructor = Cat;")]),s._v(" 写这句的目的是为了修复上一行的副作用： Cat.prototype.constructor 会指向 Animal。\n            ")]),s._v(" "),a("p",[s._v("\n                更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。也就是，也会指向Animal。\n            ")]),s._v(" "),a("p",[s._v("\n                所以，需要将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。\n            ")]),s._v(" "),a("p",[s._v("\n                这是很重要的一点，务必要遵守。也就是，如果替换了prototype对象，"),a("code",[s._v("o.prototype = {};")])]),s._v(" "),a("p",[s._v("\n                那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。"),a("code",[s._v("o.prototype.constructor = o;")])]),s._v(" "),a("p",[s._v("\n                另外，这种方法有一个缺点："),a("code",[s._v("Cat.prototype.doSomething")]),s._v(" 必须写在 "),a("code",[s._v("Cat.prototype = new Animal();")]),s._v("之后，不然会被覆盖。\n            ")]),s._v(" "),a("h2",[s._v("3.组合式继承(前两种方式的结合)")]),s._v(" "),a("p",[s._v("\n                其背后的思路是："),a("strong",[s._v("使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承")]),s._v("。\n                "),a("pre",{staticClass:"hljs qml"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Animal")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".species = "),a("span",{staticClass:"hljs-string"},[s._v('"动物"')]),s._v(";"),a("br"),s._v("}"),a("br"),a("br"),s._v("Animal.prototype.doSomething = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'Animal do something'")]),s._v(");"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Cat")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("name, color")]),s._v(") ")]),s._v("{"),a("br"),s._v("    Animal.apply("),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(", "),a("span",{staticClass:"hljs-built_in"},[s._v("arguments")]),s._v(");"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name = name;"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = "),a("span",{staticClass:"hljs-built_in"},[s._v("color")]),s._v(";"),a("br"),s._v("}"),a("br"),a("br"),s._v("Cat.prototype = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Animal();"),a("br"),s._v("Cat.prototype.constructor = Cat;"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" cat1 = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Cat("),a("span",{staticClass:"hljs-string"},[s._v('"大毛"')]),s._v(", "),a("span",{staticClass:"hljs-string"},[s._v('"黄色"')]),s._v(");"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")]),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.doSomething()); "),a("span",{staticClass:"hljs-comment"},[s._v("// Animal do something")])])]),s._v("\n                但组合继承在使用过程中有个问题："),a("strong",[s._v("父类会被调用两次")]),s._v("。一次是创建子类型的时候，另一次是在子类型构造函数的内部。\n            ")]),s._v(" "),a("p",[s._v("\n                第一次将“猫”的prototype对象，指向一个Animal的实例。这一步的调用，其实只是为了获取父类原型上的方法罢了，并不需要函数内部的那些实例属性。\n            ")]),s._v(" "),a("p",[s._v("\n                所以，可能想到了要这么写："),a("code",[s._v("Cat.prototype = Animal.prototype;")]),s._v("。但，这是不对的。\n                "),a("ul",[a("li",[s._v("\n                        首先，这样写相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Cat，但实际上 Animal 并不需要，相当于强行给 Animal 添加了一个未知的方法。\n                    ")]),s._v(" "),a("li",[s._v("\n                        其次，这样写无法体现出继承的多态性。比如，Cat 要重写 Animal 的doSomething方法，那么 Animal 中的这个方法就会随之改变，显然违背了OOP多态的特性。\n                    ")])])]),s._v(" "),a("h2",[s._v("4.寄生组合式继承(利用空对象作为中介)")]),s._v(" "),a("p",[s._v("\n                因为第三种方式说，我们第一次调用构造函数时，其实不用管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Animal.prototype。\n                "),a("pre",{staticClass:"hljs elm"},[a("code",{},[a("span",{staticClass:"hljs-title"},[s._v("var")]),s._v(" "),a("span",{staticClass:"hljs-type"},[s._v("F")]),s._v(" = function(){};"),a("br"),a("span",{staticClass:"hljs-type"},[s._v("F")]),s._v(".proto"),a("span",{staticClass:"hljs-keyword"},[s._v("type")]),s._v(" = "),a("span",{staticClass:"hljs-type"},[s._v("Animal")]),s._v(".prototype;"),a("br"),a("br"),a("span",{staticClass:"hljs-type"},[s._v("Cat")]),s._v(".proto"),a("span",{staticClass:"hljs-keyword"},[s._v("type")]),s._v(" = new "),a("span",{staticClass:"hljs-type"},[s._v("F")]),s._v("();"),a("br"),a("span",{staticClass:"hljs-type"},[s._v("Cat")]),s._v(".proto"),a("span",{staticClass:"hljs-keyword"},[s._v("type")]),s._v(".constructor = "),a("span",{staticClass:"hljs-type"},[s._v("Cat")]),s._v(";")])]),s._v("\n                F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。\n            ")]),s._v(" "),a("p",[s._v("\n                将上面的方法封装一个，以便调用。\n                "),a("pre",{staticClass:"hljs php"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("extend")]),a("span",{staticClass:"hljs-params"},[s._v("(Child, Parent)")]),s._v(" ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" F = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),a("span",{staticClass:"hljs-params"},[s._v("()")])]),s._v("{};"),a("br"),s._v("    F.prototype = "),a("span",{staticClass:"hljs-keyword"},[s._v("Parent")]),s._v(".prototype;"),a("br"),a("br"),s._v("    Child.prototype = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" F();"),a("br"),s._v("    Child.prototype.constructor = Child;"),a("br"),a("br"),s._v("    Child.uber = "),a("span",{staticClass:"hljs-keyword"},[s._v("Parent")]),s._v(".prototype;"),a("br"),s._v("}")])]),s._v("\n                使用的时候，像下面这样：\n                "),a("pre",{staticClass:"hljs stata"},[a("code",{},[s._v("extend("),a("span",{staticClass:"hljs-keyword"},[s._v("Cat")]),s._v(", Animal);"),a("br"),a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" cat1 = new "),a("span",{staticClass:"hljs-keyword"},[s._v("Cat")]),s._v("("),a("span",{staticClass:"hljs-string"},[s._v('"大毛"')]),s._v(", "),a("span",{staticClass:"hljs-string"},[s._v('"黄色"')]),s._v(");"),a("br"),a("br"),s._v("console."),a("span",{staticClass:"hljs-built_in"},[s._v("log")]),s._v("(cat1.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")]),a("br"),s._v("console."),a("span",{staticClass:"hljs-built_in"},[s._v("log")]),s._v("(cat1.doSomething()); "),a("span",{staticClass:"hljs-comment"},[s._v("// Animal do something")])])]),s._v("\n                这个extend函数，就是YUI库如何实现继承的方法。\n            ")]),s._v(" "),a("p",[s._v("\n                另外，说明一点，函数体最后一行"),a("code",[s._v("Child.uber = Parent.prototype;")]),s._v('。意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是"向上"、"上一层"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。\n            ')]),s._v(" "),a("h2",[s._v("5.拷贝继承")]),s._v(" "),a("p",[s._v('\n                换一种思路，纯粹采用"拷贝"方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象。\n                '),a("pre",{staticClass:"hljs qml"},[a("code",{},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Animal")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{}"),a("br"),s._v("Animal.prototype.species = "),a("span",{staticClass:"hljs-string"},[s._v('"动物"')]),s._v(";"),a("br"),s._v("Animal.prototype.doSomething = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'Animal do something'")]),s._v(");"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Cat")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("name, color")]),s._v(") ")]),s._v("{"),a("br"),s._v("    Animal.apply("),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(", "),a("span",{staticClass:"hljs-built_in"},[s._v("arguments")]),s._v(");"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name = name;"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = "),a("span",{staticClass:"hljs-built_in"},[s._v("color")]),s._v(";"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("extend2")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("Child, Parent")]),s._v(") ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" p = Parent.prototype;"),a("br"),s._v("    "),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" c = Child.prototype;"),a("br"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" i "),a("span",{staticClass:"hljs-keyword"},[s._v("in")]),s._v(" p) {"),a("br"),s._v("        c[i] = p[i];"),a("br"),s._v("    }"),a("br"),s._v("    c.uber = p;"),a("br"),s._v("}"),a("br"),a("br"),s._v("extend2(Cat, Animal);"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("var")]),s._v(" cat1 = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Cat("),a("span",{staticClass:"hljs-string"},[s._v('"大毛"')]),s._v(", "),a("span",{staticClass:"hljs-string"},[s._v('"黄色"')]),s._v(");"),a("br"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")]),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.doSomething()); "),a("span",{staticClass:"hljs-comment"},[s._v("// Animal do something")])])])]),s._v(" "),a("h2",[s._v("6.ES6中的class方法")]),s._v(" "),a("p",[s._v("\n                ES6中写继承关系更为简单，用到了 extends 关键字。\n                "),a("pre",{staticClass:"hljs javascript"},[a("code",{},[a("span",{staticClass:"hljs-class"},[a("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Animal")]),s._v(" ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("() {"),a("br"),s._v("        "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".species = "),a("span",{staticClass:"hljs-string"},[s._v('"动物"')]),s._v(";"),a("br"),s._v("    }"),a("br"),s._v("    doSomething() {"),a("br"),s._v("        "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'Animal do something'")]),s._v(");"),a("br"),s._v("    }"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-class"},[a("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Cat")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("extends")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Animal")]),s._v(" ")]),s._v("{"),a("br"),s._v("    "),a("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(name, color) {"),a("br"),s._v("        "),a("span",{staticClass:"hljs-keyword"},[s._v("super")]),s._v("();"),a("br"),s._v("        "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".name = name;"),a("br"),s._v("        "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".color = color;"),a("br"),s._v("    }"),a("br"),s._v("    doSomething() {"),a("br"),s._v("        "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),a("span",{staticClass:"hljs-string"},[s._v("'cat catches mouse'")]),s._v(");"),a("br"),s._v("    }"),a("br"),s._v("}"),a("br"),a("br"),a("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" cat1 = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Cat("),a("span",{staticClass:"hljs-string"},[s._v('"大毛"')]),s._v(", "),a("span",{staticClass:"hljs-string"},[s._v('"黄色"')]),s._v(");"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")]),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(cat1.doSomething()); "),a("span",{staticClass:"hljs-comment"},[s._v("// cat catches mouse")]),a("br"),a("br"),a("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" animal = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Animal();"),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(animal.species); "),a("span",{staticClass:"hljs-comment"},[s._v("// 动物")]),a("br"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(animal.doSomething()); "),a("span",{staticClass:"hljs-comment"},[s._v("// Animal do something")])])])]),s._v(" "),a("h2",[s._v("参考文献")]),s._v(" "),a("p",[a("ul",[a("li",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html",target:"_blank"}},[s._v("\n                            Javascript面向对象编程（二）：构造函数的继承\n                        ")])])])])])])],1)},[],!1,null,null,null);_.options.__file="inherit-in-javascript.vue";t.default=_.exports}}]);