<template>
    <div class="blog-container">
        <BlogHeader></BlogHeader>

        <BlogContent>
            <div slot="content">
                <h2>前言</h2>
                <p>
                    接着上一篇文章 <a href="" target="_blank">lodash 是如何实现深拷贝的（上）</a>，今天会继续解读 _.cloneDeep 的源码，来看看 lodash 是如何处理对象、函数、循环引用等的深拷贝问题的。
                </p>

                <h2>baseClone 的源码实现</h2>
                <p>
                    先回顾一下它的源码，以及一些关键的注释
                    <pre class="hljs cs"><code class=""><span class="hljs-function">function <span class="hljs-title">baseClone</span>(<span class="hljs-params"><span class="hljs-keyword">value</span>, bitmask, customizer, key, <span class="hljs-keyword">object</span>, stack</span>)</span> {<br>  <span class="hljs-keyword">let</span> result<br>  <span class="hljs-comment">// 根据位掩码，切分判断入口</span><br>  <span class="hljs-keyword">const</span> isDeep = bitmask &amp; CLONE_DEEP_FLAG<br>  <span class="hljs-keyword">const</span> isFlat = bitmask &amp; CLONE_FLAT_FLAG<br>  <span class="hljs-keyword">const</span> isFull = bitmask &amp; CLONE_SYMBOLS_FLAG<br><br>  <span class="hljs-comment">// 自定义 clone 方法，用于 _.cloneWith</span><br>  <span class="hljs-keyword">if</span> (customizer) {<br>    result = <span class="hljs-keyword">object</span> ? customizer(<span class="hljs-keyword">value</span>, key, <span class="hljs-keyword">object</span>, stack) : customizer(<span class="hljs-keyword">value</span>)<br>  }<br>  <span class="hljs-keyword">if</span> (result !== undefined) {<br>    <span class="hljs-keyword">return</span> result<br>  }<br><br>  <span class="hljs-comment">// 过滤出原始类型，直接返回</span><br>  <span class="hljs-keyword">if</span> (!isObject(<span class="hljs-keyword">value</span>)) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span><br>  }<br>  <br>  <span class="hljs-keyword">const</span> isArr = Array.isArray(<span class="hljs-keyword">value</span>)<br>  <span class="hljs-keyword">const</span> tag = getTag(<span class="hljs-keyword">value</span>)<br>  <span class="hljs-keyword">if</span> (isArr) {<br>    <span class="hljs-comment">// 处理数组</span><br>    result = initCloneArray(<span class="hljs-keyword">value</span>)<br>    <span class="hljs-keyword">if</span> (!isDeep) {<br>      <span class="hljs-comment">// 浅拷贝数组</span><br>      <span class="hljs-keyword">return</span> copyArray(<span class="hljs-keyword">value</span>, result)<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 处理对象</span><br>    <span class="hljs-keyword">const</span> isFunc = <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">value</span> == <span class="hljs-string">'function'</span><br>    <br>    <span class="hljs-keyword">if</span> (isBuffer(<span class="hljs-keyword">value</span>)) {<br>      <span class="hljs-keyword">return</span> cloneBuffer(<span class="hljs-keyword">value</span>, isDeep)<br>    }<br>    <span class="hljs-keyword">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !<span class="hljs-keyword">object</span>)) {<br>      result = (isFlat || isFunc) ? {} : initCloneObject(<span class="hljs-keyword">value</span>)<br>      <span class="hljs-keyword">if</span> (!isDeep) {<br>        <span class="hljs-keyword">return</span> isFlat<br>          ? copySymbolsIn(<span class="hljs-keyword">value</span>, copyObject(<span class="hljs-keyword">value</span>, keysIn(<span class="hljs-keyword">value</span>), result))<br>          : copySymbols(<span class="hljs-keyword">value</span>, Object.assign(result, <span class="hljs-keyword">value</span>))<br>      }<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-keyword">if</span> (isFunc || !cloneableTags[tag]) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> ? <span class="hljs-keyword">value</span> : {}<br>      }<br>      result = initCloneByTag(<span class="hljs-keyword">value</span>, tag, isDeep)<br>    }<br>  }<br>  <span class="hljs-comment">// 用 “栈” 处理循环引用</span><br>  stack || (stack = <span class="hljs-keyword">new</span> Stack)<br>  <span class="hljs-keyword">const</span> stacked = stack.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">value</span>)<br>  <span class="hljs-keyword">if</span> (stacked) {<br>    <span class="hljs-keyword">return</span> stacked<br>  }<br>  stack.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">value</span>, result)<br><br>  <span class="hljs-comment">// 处理 Map</span><br>  <span class="hljs-keyword">if</span> (tag == mapTag) {<br>    <span class="hljs-keyword">value</span>.forEach((subValue, key) =&gt; {<br>      result.<span class="hljs-keyword">set</span>(key, baseClone(subValue, bitmask, customizer, key, <span class="hljs-keyword">value</span>, stack))<br>    })<br>    <span class="hljs-keyword">return</span> result<br>  }<br><br>  <span class="hljs-comment">// 处理 Set</span><br>  <span class="hljs-keyword">if</span> (tag == setTag) {<br>    <span class="hljs-keyword">value</span>.forEach((subValue) =&gt; {<br>      result.<span class="hljs-keyword">add</span>(baseClone(subValue, bitmask, customizer, subValue, <span class="hljs-keyword">value</span>, stack))<br>    })<br>    <span class="hljs-keyword">return</span> result<br>  }<br><br>  <span class="hljs-comment">// 处理 typedArray</span><br>  <span class="hljs-keyword">if</span> (isTypedArray(<span class="hljs-keyword">value</span>)) {<br>    <span class="hljs-keyword">return</span> result<br>  }<br><br>  <span class="hljs-keyword">const</span> keysFunc = isFull<br>    ? (isFlat ? getAllKeysIn : getAllKeys)<br>    : (isFlat ? keysIn : keys)<br><br>  <span class="hljs-keyword">const</span> props = isArr ? undefined : keysFunc(<span class="hljs-keyword">value</span>)<br><br>  <span class="hljs-comment">// 遍历赋值</span><br>  arrayEach(props || <span class="hljs-keyword">value</span>, (subValue, key) =&gt; {<br>    <span class="hljs-keyword">if</span> (props) {<br>      key = subValue<br>      subValue = <span class="hljs-keyword">value</span>[key]<br>    }<br>    <span class="hljs-comment">// Recursively populate clone (susceptible to call stack limits).</span><br>    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, <span class="hljs-keyword">value</span>, stack))<br>  })<br><br>  <span class="hljs-keyword">return</span> result<br>}<br></code></pre>
                </p>

                <h4>处理对象和函数</h4>
                <p>
                    一些主要的判断入口，已经加上了注释。
                    <pre class="hljs cs"><code class=""><span class="hljs-keyword">const</span> isArr = Array.isArray(<span class="hljs-keyword">value</span>)<br><span class="hljs-keyword">const</span> tag = getTag(<span class="hljs-keyword">value</span>)<br><br><span class="hljs-keyword">if</span> (isArr) {<br>    ... <span class="hljs-comment">// 刚才数组的处理</span><br>} <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 开始处理对象</span><br>    <span class="hljs-comment">// 对象是函数的标志位</span><br>    <span class="hljs-keyword">const</span> isFunc = <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">value</span> == <span class="hljs-string">'function'</span><br>    <br>    <span class="hljs-comment">// 处理 Buffer（缓冲区）对象</span><br>    <span class="hljs-keyword">if</span> (isBuffer(<span class="hljs-keyword">value</span>)) {<br>        <span class="hljs-keyword">return</span> cloneBuffer(<span class="hljs-keyword">value</span>, isDeep)<br>    }<br>    <br>    <span class="hljs-comment">// 如果 tag 是 '[object Object]'</span><br>    <span class="hljs-comment">// 或 tag 是 '[object Arguments]'</span><br>    <span class="hljs-comment">// 或 是函数但没有父对象（object 由 baseClone 传入，是 value 的父对象）</span><br>    <span class="hljs-keyword">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !<span class="hljs-keyword">object</span>)) {<br>        <span class="hljs-comment">// 初始化 result</span><br>        <span class="hljs-comment">// 如果是原型链或函数时，设置为空对象</span><br>        <span class="hljs-comment">// 否则，新开一个对象，并将源对象的键值对依次拷贝进去</span><br>        result = (isFlat || isFunc) ? {} : initCloneObject(<span class="hljs-keyword">value</span>)<br>        <span class="hljs-keyword">if</span> (!isDeep) {<br>            <span class="hljs-comment">// 进入对象的浅拷贝</span><br>            <span class="hljs-keyword">return</span> isFlat<br>            <span class="hljs-comment">// 如果是原型链，则需要拷贝自身，还有继承的 symbols</span><br>            ? copySymbolsIn(<span class="hljs-keyword">value</span>, copyObject(<span class="hljs-keyword">value</span>, keysIn(<span class="hljs-keyword">value</span>), result))<br>            <span class="hljs-comment">// 否则，只要拷贝自身的 symbols</span><br>            : copySymbols(<span class="hljs-keyword">value</span>, Object.assign(result, <span class="hljs-keyword">value</span>))<br>        }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// 是函数 或者 不是error类型 或者 不是weakmap类型时</span><br>        <span class="hljs-keyword">if</span> (isFunc || !cloneableTags[tag]) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> ? <span class="hljs-keyword">value</span> : {}<br>        }<br>        <span class="hljs-comment">// 按需要初始化 cloneableTags 对象中剩余的类型</span><br>        result = initCloneByTag(<span class="hljs-keyword">value</span>, tag, isDeep)<br>    }<br>}</code></pre>
                    其中，<code>isBuffer</code> 会处理 Buffer 类的拷贝，它是 Node.js 中的概念，用来创建一个专门存放二进制数据的缓存区，可以让 Node.js 处理二进制数据。
                </p>
                <p>
                    在 baseClone 的外面，还定义了一个对象 cloneableTags，里面只有 error 和 weakmap 类型会返回 false，所以 <code>!cloneableTags[tag]</code> 的意思就是，不是 error 或 weakmap 类型。
                </p>
                <p>
                    接下来，来看如何初始化一个新的 Object 对象。
                    <pre class="hljs cs"><code class=""><span class="hljs-function">function <span class="hljs-title">initCloneObject</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>)</span> {<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">object</span>.constructor == <span class="hljs-string">'function'</span> &amp;&amp; !isPrototype(<span class="hljs-keyword">object</span>))<br>        ? Object.create(Object.getPrototypeOf(<span class="hljs-keyword">object</span>))<br>        : {}<br>}<br><br><span class="hljs-comment">// ./isPrototype.js</span><br><span class="hljs-keyword">const</span> objectProto = Object.prototype<br><span class="hljs-comment">// 用于检测自己是否在自己的原型链上</span><br><span class="hljs-function">function <span class="hljs-title">isPrototype</span>(<span class="hljs-params"><span class="hljs-keyword">value</span></span>)</span> {<br>    <span class="hljs-keyword">const</span> Ctor = <span class="hljs-keyword">value</span> &amp;&amp; <span class="hljs-keyword">value</span>.constructor<br>    <span class="hljs-comment">// 如果 value 是函数，则取出该函数的原型对象</span><br>    <span class="hljs-comment">// 否则，取出对象的原型对象</span><br>    <span class="hljs-keyword">const</span> proto = (<span class="hljs-keyword">typeof</span> Ctor == <span class="hljs-string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> === proto<br>}</code></pre>
                    其中，<code>typeof object.constructor == 'function'</code> 的判断，是为了确定 value 的类型是对象或数组。
                </p>
                <p>
                    然后用 <code>Object.create</code> 生成新的对象。<code>Object.create()</code> 方法用于创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__。
                </p>
                <p>
                    <code>object.constructor</code> 相当于 <code>new Object()</code>，而 Object 的构造函数是一个函数对象。
                    <pre class="hljs typescript"><code class=""><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> obj.constructor);<br><span class="hljs-comment">// 'function'</span></code></pre>
                </p>
                <p>
                    对象的原型，可以通过 <code>Object.getPrototypeOf(obj)</code> 获取，它相当于过去使用的 <code>__proto__</code>。
                </p>
                <p>
                    <code>initCloneByTag</code> 方法会处理剩余的多种类型的拷贝，有原始类型，也有如 <code>dateTag</code>、<code>dataViewTag</code>、<code>float32Tag</code>、<code>int16Tag</code>、<code>mapTag</code>、<code>setTag</code>、<code>regexpTag</code> 等等。
                </p>
                <p>
                    其中，<code>cloneTypedArray</code> 方法用于拷贝类型数组。类型数组，是一种类似数组的对象，它由 ArrayBuffer、TypedArray、DataView 三类对象构成，通过这些对象为 JavaScript 提供了访问二进制数据的能力。
                </p>

                <h4>循环引用</h4>
                <p>
                    <pre class="hljs cpp"><code class=""><span class="hljs-comment">// 如果有 stack 作为参数传入，就用参数中的 stack</span><br><span class="hljs-comment">// 不然就 new 一个 Stack</span><br><span class="hljs-built_in">stack</span> || (<span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack)<br><span class="hljs-keyword">const</span> stacked = <span class="hljs-built_in">stack</span>.get(value)<br><span class="hljs-keyword">if</span> (stacked) {<br>    <span class="hljs-keyword">return</span> stacked<br>}<br><span class="hljs-built_in">stack</span>.<span class="hljs-built_in">set</span>(value, result)</code></pre>
                    与 <a href="" target="_blank">「前端面试题系列9」浅拷贝与深拷贝的含义、区别及实现</a> 最后提到的 cloneForce 方案类似，利用了栈来解决循环引用的问题。
                </p>
                <p>
                    如果 <code>stacked</code> 有值，则表明已经在栈中存在，不然就 <code>value</code> 和 <code>result</code> 入栈。在 Stack 中的 set 方法：
                    <pre class="hljs kotlin"><code class=""><span class="hljs-keyword">constructor</span>(entries) {<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = <span class="hljs-keyword">this</span>.__data__ = new ListCache(entries)<br>    <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">data</span>.size<br>}<br><br><span class="hljs-keyword">set</span>(key, value) {<br>    let <span class="hljs-keyword">data</span> = <span class="hljs-keyword">this</span>.__data__<br>    <span class="hljs-comment">// data 是否在 ListCache 的构造函数中存在</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> instanceof ListCache) {<br>        <span class="hljs-keyword">const</span> pairs = <span class="hljs-keyword">data</span>.__data__<br>        <span class="hljs-comment">// LARGE_ARRAY_SIZE 为 200</span><br>        <span class="hljs-keyword">if</span> (pairs.length &lt; LARGE_ARRAY_SIZE - <span class="hljs-number">1</span>) {<br>            pairs.push([key, value])<br>            <span class="hljs-keyword">this</span>.size = ++<span class="hljs-keyword">data</span>.size<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>        }<br>        <span class="hljs-comment">// 超出200，则重置 data</span><br>        <span class="hljs-keyword">data</span> = <span class="hljs-keyword">this</span>.__data__ = new MapCache(pairs)<br>    }<br>    <span class="hljs-comment">// data 不在 ListCache 的构造函数中，则直接进行 set 操作</span><br>    <span class="hljs-keyword">data</span>.<span class="hljs-keyword">set</span>(key, value)<br>    <span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">data</span>.size<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>}</code></pre>
                </p>

                <h4>Map 和 Set</h4>
                <p>
                    这两个类型的深拷贝利用了递归的思想，只是添加元素的方式有区别，<code>Map</code> 用 <code>set</code>，<code>Set</code> 用 <code>add</code>。
                    <pre class="hljs cs"><code class=""><span class="hljs-keyword">if</span> (tag == mapTag) {<br>    <span class="hljs-keyword">value</span>.forEach((subValue, key) =&gt; {<br>      result.<span class="hljs-keyword">set</span>(key, baseClone(subValue, bitmask, customizer, key, <span class="hljs-keyword">value</span>, stack))<br>    })<br>    <span class="hljs-keyword">return</span> result<br>  }<br><br>  <span class="hljs-keyword">if</span> (tag == setTag) {<br>    <span class="hljs-keyword">value</span>.forEach((subValue) =&gt; {<br>      result.<span class="hljs-keyword">add</span>(baseClone(subValue, bitmask, customizer, subValue, <span class="hljs-keyword">value</span>, stack))<br>    })<br>    <span class="hljs-keyword">return</span> result<br>}</code></pre>
                </p>

                <h4>Symbol 和 原型链</h4>
                <p>
                    <pre class="hljs cs"><code class=""><span class="hljs-comment">// 获取数组 keys</span><br><span class="hljs-keyword">const</span> keysFunc = isFull<br>    ? (isFlat ? getAllKeysIn : getAllKeys)<br>    : (isFlat ? keysIn : keys)<br><br><span class="hljs-keyword">const</span> props = isArr ? undefined : keysFunc(<span class="hljs-keyword">value</span>)<br>arrayEach(props || <span class="hljs-keyword">value</span>, (subValue, key) =&gt; {<br>    <span class="hljs-comment">// 如果 props 有值，则替换 key 和 subValue</span><br>    <span class="hljs-keyword">if</span> (props) {<br>        key = subValue<br>        subValue = <span class="hljs-keyword">value</span>[key]<br>    }<br>    <span class="hljs-comment">// 递归克隆（易受调用堆栈限制）</span><br>    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, <span class="hljs-keyword">value</span>, stack))<br>})<br><br><span class="hljs-keyword">return</span> result<br><br><span class="hljs-comment">// ./getAllKeysIn</span><br><span class="hljs-comment">// 返回一个包含 自身 和 原型链上的属性名 以及Symbol 的数组</span><br><span class="hljs-function">function <span class="hljs-title">getAllKeysIn</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>)</span> {<br>    <span class="hljs-keyword">const</span> result = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) {<br>        result.push(key)<br>    }<br>    <span class="hljs-keyword">if</span> (!Array.isArray(<span class="hljs-keyword">object</span>)) {<br>        result.push(...getSymbolsIn(<span class="hljs-keyword">object</span>))<br>    }<br>    <span class="hljs-keyword">return</span> result<br>}<br><br><span class="hljs-comment">// ./getAllKeys</span><br><span class="hljs-comment">// 返回一个包含 自身 和 Symbol 的数组</span><br><span class="hljs-function">function <span class="hljs-title">getAllKeys</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>)</span> {<br>    <span class="hljs-keyword">const</span> result = keys(<span class="hljs-keyword">object</span>)<br>    <span class="hljs-keyword">if</span> (!Array.isArray(<span class="hljs-keyword">object</span>)) {<br>        result.push(...getSymbols(<span class="hljs-keyword">object</span>))<br>    }<br>    <span class="hljs-keyword">return</span> result<br>}<br><br><span class="hljs-comment">// ./keysIn</span><br><span class="hljs-comment">// 返回一个 自身 和 原型链上的属性名 的数组</span><br><span class="hljs-function">function <span class="hljs-title">keysIn</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>)</span> {<br>    <span class="hljs-keyword">const</span> result = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) {<br>        result.push(key)<br>    }<br>    <span class="hljs-keyword">return</span> result<br>}<br><br><span class="hljs-comment">// ./keys</span><br><span class="hljs-comment">// 返回一个 自身属性名 的数组</span><br><span class="hljs-function">function <span class="hljs-title">keys</span>(<span class="hljs-params"><span class="hljs-keyword">object</span></span>)</span> {<br>    <span class="hljs-keyword">return</span> isArrayLike(<span class="hljs-keyword">object</span>)<br>        ? arrayLikeKeys(<span class="hljs-keyword">object</span>)<br>        : Object.keys(Object(<span class="hljs-keyword">object</span>))<br>}</code></pre>
                    最后来看下 <code>assignValue</code> 的实现。
                    <pre class="hljs cs"><code class=""><span class="hljs-comment">// ./assignValue</span><br><span class="hljs-keyword">const</span> hasOwnProperty = Object.prototype.<span class="hljs-function">hasOwnProperty</span><br><span class="hljs-function"></span><br><span class="hljs-function">function <span class="hljs-title">assignValue</span>(<span class="hljs-params"><span class="hljs-keyword">object</span>, key, <span class="hljs-keyword">value</span></span>)</span> {<br>  <span class="hljs-keyword">const</span> objValue = <span class="hljs-keyword">object</span>[key]<br><br>  <span class="hljs-keyword">if</span> (!(hasOwnProperty.call(<span class="hljs-keyword">object</span>, key) &amp;&amp; eq(objValue, <span class="hljs-keyword">value</span>))) {<br>    <span class="hljs-comment">// value 非零或者可用</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> !== <span class="hljs-number">0</span> || (<span class="hljs-number">1</span> / <span class="hljs-keyword">value</span>) == (<span class="hljs-number">1</span> / objValue)) {<br>      baseAssignValue(<span class="hljs-keyword">object</span>, key, <span class="hljs-keyword">value</span>)<br>    }<br>  <span class="hljs-comment">// value 未定义，并且 object 中没有 key</span><br>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> === undefined &amp;&amp; !(key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>)) {<br>    baseAssignValue(<span class="hljs-keyword">object</span>, key, <span class="hljs-keyword">value</span>)<br>  }<br>}<br><br><span class="hljs-comment">// ./baseAssignValue</span><br><span class="hljs-comment">// 赋值的基础实现</span><br><span class="hljs-function">function <span class="hljs-title">baseAssignValue</span>(<span class="hljs-params"><span class="hljs-keyword">object</span>, key, <span class="hljs-keyword">value</span></span>)</span> {<br>  <span class="hljs-keyword">if</span> (key == <span class="hljs-string">'__proto__'</span>) {<br>    Object.defineProperty(<span class="hljs-keyword">object</span>, key, {<br>      <span class="hljs-string">'configurable'</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-string">'enumerable'</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-string">'value'</span>: <span class="hljs-keyword">value</span>,<br>      <span class="hljs-string">'writable'</span>: <span class="hljs-literal">true</span><br>    })<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">object</span>[key] = <span class="hljs-keyword">value</span><br>  }<br>}<br><br><span class="hljs-comment">// ./eq</span><br><span class="hljs-comment">// 比较两个值是否相等</span><br><span class="hljs-function">function <span class="hljs-title">eq</span>(<span class="hljs-params"><span class="hljs-keyword">value</span>, other</span>)</span> {<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> === other || (<span class="hljs-keyword">value</span> !== <span class="hljs-keyword">value</span> &amp;&amp; other !== other)<br>}</code></pre>
                    最后的 eq 方法中的判断 <code>value !== value && other !== other</code>，这样的写法是为了判断 NaN。具体的可以参考这篇 <a href="https://juejin.im/post/5c8c6c26f265da2db3059c93" target="_blank">「读懂源码系列2」我从 lodash 源码中学到的几个知识点</a>
                </p>

                <h2>总结</h2>
                <p>
                    cloneDeep 中囊括了各种类型的深拷贝方法，比如 node 中的 buffer，类型数组等。用了栈的思想，解决循环引用的问题。Map 和 Set 的添加元素方法比较类似，分别为 set 和 add。NaN 是不等于自身的。
                </p>
                <p>
                    深拷贝的源码解读，到此已经完结了。本篇的写作过程，同样地耗费了好几个晚上的时间，感觉真的是自己在跟自己较劲。只因为我想尽可能地把源码的实现过程说明白，其中查找资料也挺花时间的。
                </p>
                <p>
                    在写上篇的时候，就曾有几次问自己，写源码解读的系列是不是自己坑了自己？因为我的文章都是周更的，每周更新一篇在公众号《超哥前端小栈》上，也会同步更新到 <a href="https://juejin.im/user/5a5d4522518825732b19d364" target="_blank">掘金</a>、<a href="https://segmentfault.com/u/micherwa" target="_blank">segmentfault</a> 和 <a href="https://github.com/micherwa" target="_blank">github</a> 上。
                </p>
                <p>
                    看过我文章的读者应该了解，我的文章大致分为面试系列、干货系列、源码解读系列以及其他的一些总结性文章。而写源码解读所耗费的时间，几乎是其他系列两到三倍。好在最终硬挺了下来，没有中途放弃，所以收获也颇丰。一些从源码中学到的技巧，也被我用到了实际项目中，提升了性能与可读性。不过毕竟时间精力有限，在表述上有纰漏的地方，还望读者能多加指正，多多支持，期待能有更多的交流，感谢~
                </p>
            </div>
        </BlogContent>
    </div>
</template>

<script>
    export default {

    };
</script>
